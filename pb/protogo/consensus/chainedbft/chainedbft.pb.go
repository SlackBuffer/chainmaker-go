// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: consensus/chainedbft/chainedbft.proto

package chainedbft

import (
	common "chainmaker.org/chainmaker-go/pb/protogo/common"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type BlockFetchStatus int32

const (
	BlockFetchStatus_Succeeded       BlockFetchStatus = 0
	BlockFetchStatus_IdNotFound      BlockFetchStatus = 1
	BlockFetchStatus_NotEnoughBlocks BlockFetchStatus = 2
)

var BlockFetchStatus_name = map[int32]string{
	0: "Succeeded",
	1: "IdNotFound",
	2: "NotEnoughBlocks",
}

var BlockFetchStatus_value = map[string]int32{
	"Succeeded":       0,
	"IdNotFound":      1,
	"NotEnoughBlocks": 2,
}

func (x BlockFetchStatus) String() string {
	return proto.EnumName(BlockFetchStatus_name, int32(x))
}

func (BlockFetchStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{0}
}

type ConsStateType int32

const (
	ConsStateType_NewHeight ConsStateType = 0
	ConsStateType_NewLevel  ConsStateType = 1
	ConsStateType_Propose   ConsStateType = 2
	ConsStateType_Vote      ConsStateType = 3
	ConsStateType_PaceMaker ConsStateType = 4
)

var ConsStateType_name = map[int32]string{
	0: "NewHeight",
	1: "NewLevel",
	2: "Propose",
	3: "Vote",
	4: "PaceMaker",
}

var ConsStateType_value = map[string]int32{
	"NewHeight": 0,
	"NewLevel":  1,
	"Propose":   2,
	"Vote":      3,
	"PaceMaker": 4,
}

func (x ConsStateType) String() string {
	return proto.EnumName(ConsStateType_name, int32(x))
}

func (ConsStateType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{1}
}

type MessageType int32

const (
	MessageType_ProposalMessage       MessageType = 0
	MessageType_VoteMessage           MessageType = 1
	MessageType_BlockFetchMessage     MessageType = 2
	MessageType_BlockFetchRespMessage MessageType = 3
)

var MessageType_name = map[int32]string{
	0: "ProposalMessage",
	1: "VoteMessage",
	2: "BlockFetchMessage",
	3: "BlockFetchRespMessage",
}

var MessageType_value = map[string]int32{
	"ProposalMessage":       0,
	"VoteMessage":           1,
	"BlockFetchMessage":     2,
	"BlockFetchRespMessage": 3,
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{2}
}

type QuorumCert struct {
	BlockID []byte      `protobuf:"bytes,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	Height  uint64      `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Level   uint64      `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	NewView bool        `protobuf:"varint,4,opt,name=NewView,proto3" json:"NewView,omitempty"`
	EpochId uint64      `protobuf:"varint,5,opt,name=EpochId,proto3" json:"EpochId,omitempty"`
	Votes   []*VoteData `protobuf:"bytes,6,rep,name=Votes,proto3" json:"Votes,omitempty"`
}

func (m *QuorumCert) Reset()         { *m = QuorumCert{} }
func (m *QuorumCert) String() string { return proto.CompactTextString(m) }
func (*QuorumCert) ProtoMessage()    {}
func (*QuorumCert) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{0}
}
func (m *QuorumCert) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *QuorumCert) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_QuorumCert.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *QuorumCert) XXX_Merge(src proto.Message) {
	xxx_messageInfo_QuorumCert.Merge(m, src)
}
func (m *QuorumCert) XXX_Size() int {
	return m.Size()
}
func (m *QuorumCert) XXX_DiscardUnknown() {
	xxx_messageInfo_QuorumCert.DiscardUnknown(m)
}

var xxx_messageInfo_QuorumCert proto.InternalMessageInfo

func (m *QuorumCert) GetBlockID() []byte {
	if m != nil {
		return m.BlockID
	}
	return nil
}

func (m *QuorumCert) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *QuorumCert) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *QuorumCert) GetNewView() bool {
	if m != nil {
		return m.NewView
	}
	return false
}

func (m *QuorumCert) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *QuorumCert) GetVotes() []*VoteData {
	if m != nil {
		return m.Votes
	}
	return nil
}

type ConsensusInfo struct {
	QC *QuorumCert `protobuf:"bytes,1,opt,name=QC,proto3" json:"QC,omitempty"`
}

func (m *ConsensusInfo) Reset()         { *m = ConsensusInfo{} }
func (m *ConsensusInfo) String() string { return proto.CompactTextString(m) }
func (*ConsensusInfo) ProtoMessage()    {}
func (*ConsensusInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{1}
}
func (m *ConsensusInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusInfo.Merge(m, src)
}
func (m *ConsensusInfo) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusInfo proto.InternalMessageInfo

func (m *ConsensusInfo) GetQC() *QuorumCert {
	if m != nil {
		return m.QC
	}
	return nil
}

type SyncInfo struct {
	HighestQC      *QuorumCert `protobuf:"bytes,1,opt,name=HighestQC,proto3" json:"HighestQC,omitempty"`
	HighestTC      *QuorumCert `protobuf:"bytes,2,opt,name=HighestTC,proto3" json:"HighestTC,omitempty"`
	HighestTCLevel uint64      `protobuf:"varint,3,opt,name=HighestTCLevel,proto3" json:"HighestTCLevel,omitempty"`
}

func (m *SyncInfo) Reset()         { *m = SyncInfo{} }
func (m *SyncInfo) String() string { return proto.CompactTextString(m) }
func (*SyncInfo) ProtoMessage()    {}
func (*SyncInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{2}
}
func (m *SyncInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SyncInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SyncInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SyncInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SyncInfo.Merge(m, src)
}
func (m *SyncInfo) XXX_Size() int {
	return m.Size()
}
func (m *SyncInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_SyncInfo.DiscardUnknown(m)
}

var xxx_messageInfo_SyncInfo proto.InternalMessageInfo

func (m *SyncInfo) GetHighestQC() *QuorumCert {
	if m != nil {
		return m.HighestQC
	}
	return nil
}

func (m *SyncInfo) GetHighestTC() *QuorumCert {
	if m != nil {
		return m.HighestTC
	}
	return nil
}

func (m *SyncInfo) GetHighestTCLevel() uint64 {
	if m != nil {
		return m.HighestTCLevel
	}
	return 0
}

type ProposalData struct {
	Block       *common.Block `protobuf:"bytes,1,opt,name=Block,proto3" json:"Block,omitempty"`
	Height      uint64        `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Level       uint64        `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	Proposer    []byte        `protobuf:"bytes,4,opt,name=Proposer,proto3" json:"Proposer,omitempty"`
	ProposerIdx uint64        `protobuf:"varint,5,opt,name=ProposerIdx,proto3" json:"ProposerIdx,omitempty"`
	EpochId     uint64        `protobuf:"varint,6,opt,name=EpochId,proto3" json:"EpochId,omitempty"`
	JustifyQC   *QuorumCert   `protobuf:"bytes,7,opt,name=JustifyQC,proto3" json:"JustifyQC,omitempty"`
}

func (m *ProposalData) Reset()         { *m = ProposalData{} }
func (m *ProposalData) String() string { return proto.CompactTextString(m) }
func (*ProposalData) ProtoMessage()    {}
func (*ProposalData) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{3}
}
func (m *ProposalData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalData.Merge(m, src)
}
func (m *ProposalData) XXX_Size() int {
	return m.Size()
}
func (m *ProposalData) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalData.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalData proto.InternalMessageInfo

func (m *ProposalData) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *ProposalData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *ProposalData) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *ProposalData) GetProposer() []byte {
	if m != nil {
		return m.Proposer
	}
	return nil
}

func (m *ProposalData) GetProposerIdx() uint64 {
	if m != nil {
		return m.ProposerIdx
	}
	return 0
}

func (m *ProposalData) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *ProposalData) GetJustifyQC() *QuorumCert {
	if m != nil {
		return m.JustifyQC
	}
	return nil
}

type ProposalMsg struct {
	ProposalData *ProposalData `protobuf:"bytes,1,opt,name=ProposalData,proto3" json:"ProposalData,omitempty"`
	SyncInfo     *SyncInfo     `protobuf:"bytes,2,opt,name=SyncInfo,proto3" json:"SyncInfo,omitempty"`
}

func (m *ProposalMsg) Reset()         { *m = ProposalMsg{} }
func (m *ProposalMsg) String() string { return proto.CompactTextString(m) }
func (*ProposalMsg) ProtoMessage()    {}
func (*ProposalMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{4}
}
func (m *ProposalMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ProposalMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ProposalMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ProposalMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ProposalMsg.Merge(m, src)
}
func (m *ProposalMsg) XXX_Size() int {
	return m.Size()
}
func (m *ProposalMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ProposalMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ProposalMsg proto.InternalMessageInfo

func (m *ProposalMsg) GetProposalData() *ProposalData {
	if m != nil {
		return m.ProposalData
	}
	return nil
}

func (m *ProposalMsg) GetSyncInfo() *SyncInfo {
	if m != nil {
		return m.SyncInfo
	}
	return nil
}

type VoteData struct {
	BlockID   []byte                   `protobuf:"bytes,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	Height    uint64                   `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	Level     uint64                   `protobuf:"varint,3,opt,name=Level,proto3" json:"Level,omitempty"`
	Author    []byte                   `protobuf:"bytes,4,opt,name=Author,proto3" json:"Author,omitempty"`
	AuthorIdx uint64                   `protobuf:"varint,5,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
	NewView   bool                     `protobuf:"varint,6,opt,name=NewView,proto3" json:"NewView,omitempty"`
	EpochId   uint64                   `protobuf:"varint,7,opt,name=EpochId,proto3" json:"EpochId,omitempty"`
	Signature *common.EndorsementEntry `protobuf:"bytes,8,opt,name=Signature,proto3" json:"Signature,omitempty"`
}

func (m *VoteData) Reset()         { *m = VoteData{} }
func (m *VoteData) String() string { return proto.CompactTextString(m) }
func (*VoteData) ProtoMessage()    {}
func (*VoteData) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{5}
}
func (m *VoteData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteData.Merge(m, src)
}
func (m *VoteData) XXX_Size() int {
	return m.Size()
}
func (m *VoteData) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteData.DiscardUnknown(m)
}

var xxx_messageInfo_VoteData proto.InternalMessageInfo

func (m *VoteData) GetBlockID() []byte {
	if m != nil {
		return m.BlockID
	}
	return nil
}

func (m *VoteData) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *VoteData) GetLevel() uint64 {
	if m != nil {
		return m.Level
	}
	return 0
}

func (m *VoteData) GetAuthor() []byte {
	if m != nil {
		return m.Author
	}
	return nil
}

func (m *VoteData) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

func (m *VoteData) GetNewView() bool {
	if m != nil {
		return m.NewView
	}
	return false
}

func (m *VoteData) GetEpochId() uint64 {
	if m != nil {
		return m.EpochId
	}
	return 0
}

func (m *VoteData) GetSignature() *common.EndorsementEntry {
	if m != nil {
		return m.Signature
	}
	return nil
}

type VoteMsg struct {
	VoteData *VoteData `protobuf:"bytes,1,opt,name=VoteData,proto3" json:"VoteData,omitempty"`
	SyncInfo *SyncInfo `protobuf:"bytes,2,opt,name=SyncInfo,proto3" json:"SyncInfo,omitempty"`
}

func (m *VoteMsg) Reset()         { *m = VoteMsg{} }
func (m *VoteMsg) String() string { return proto.CompactTextString(m) }
func (*VoteMsg) ProtoMessage()    {}
func (*VoteMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{6}
}
func (m *VoteMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *VoteMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_VoteMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *VoteMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_VoteMsg.Merge(m, src)
}
func (m *VoteMsg) XXX_Size() int {
	return m.Size()
}
func (m *VoteMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_VoteMsg.DiscardUnknown(m)
}

var xxx_messageInfo_VoteMsg proto.InternalMessageInfo

func (m *VoteMsg) GetVoteData() *VoteData {
	if m != nil {
		return m.VoteData
	}
	return nil
}

func (m *VoteMsg) GetSyncInfo() *SyncInfo {
	if m != nil {
		return m.SyncInfo
	}
	return nil
}

type BlockFetchMsg struct {
	BlockID   []byte `protobuf:"bytes,1,opt,name=BlockID,proto3" json:"BlockID,omitempty"`
	Height    uint64 `protobuf:"varint,2,opt,name=Height,proto3" json:"Height,omitempty"`
	NumBlocks uint64 `protobuf:"varint,3,opt,name=NumBlocks,proto3" json:"NumBlocks,omitempty"`
	AuthorIdx uint64 `protobuf:"varint,4,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
}

func (m *BlockFetchMsg) Reset()         { *m = BlockFetchMsg{} }
func (m *BlockFetchMsg) String() string { return proto.CompactTextString(m) }
func (*BlockFetchMsg) ProtoMessage()    {}
func (*BlockFetchMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{7}
}
func (m *BlockFetchMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockFetchMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockFetchMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockFetchMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockFetchMsg.Merge(m, src)
}
func (m *BlockFetchMsg) XXX_Size() int {
	return m.Size()
}
func (m *BlockFetchMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockFetchMsg.DiscardUnknown(m)
}

var xxx_messageInfo_BlockFetchMsg proto.InternalMessageInfo

func (m *BlockFetchMsg) GetBlockID() []byte {
	if m != nil {
		return m.BlockID
	}
	return nil
}

func (m *BlockFetchMsg) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockFetchMsg) GetNumBlocks() uint64 {
	if m != nil {
		return m.NumBlocks
	}
	return 0
}

func (m *BlockFetchMsg) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

type BlockPair struct {
	Block *common.Block `protobuf:"bytes,1,opt,name=Block,proto3" json:"Block,omitempty"`
	QC    *QuorumCert   `protobuf:"bytes,2,opt,name=QC,proto3" json:"QC,omitempty"`
}

func (m *BlockPair) Reset()         { *m = BlockPair{} }
func (m *BlockPair) String() string { return proto.CompactTextString(m) }
func (*BlockPair) ProtoMessage()    {}
func (*BlockPair) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{8}
}
func (m *BlockPair) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockPair) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockPair.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockPair) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockPair.Merge(m, src)
}
func (m *BlockPair) XXX_Size() int {
	return m.Size()
}
func (m *BlockPair) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockPair.DiscardUnknown(m)
}

var xxx_messageInfo_BlockPair proto.InternalMessageInfo

func (m *BlockPair) GetBlock() *common.Block {
	if m != nil {
		return m.Block
	}
	return nil
}

func (m *BlockPair) GetQC() *QuorumCert {
	if m != nil {
		return m.QC
	}
	return nil
}

type BlockFetchRespMsg struct {
	Status    BlockFetchStatus `protobuf:"varint,1,opt,name=Status,proto3,enum=chainedbft.BlockFetchStatus" json:"Status,omitempty"`
	Blocks    []*BlockPair     `protobuf:"bytes,2,rep,name=Blocks,proto3" json:"Blocks,omitempty"`
	AuthorIdx uint64           `protobuf:"varint,3,opt,name=AuthorIdx,proto3" json:"AuthorIdx,omitempty"`
}

func (m *BlockFetchRespMsg) Reset()         { *m = BlockFetchRespMsg{} }
func (m *BlockFetchRespMsg) String() string { return proto.CompactTextString(m) }
func (*BlockFetchRespMsg) ProtoMessage()    {}
func (*BlockFetchRespMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{9}
}
func (m *BlockFetchRespMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockFetchRespMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockFetchRespMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockFetchRespMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockFetchRespMsg.Merge(m, src)
}
func (m *BlockFetchRespMsg) XXX_Size() int {
	return m.Size()
}
func (m *BlockFetchRespMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockFetchRespMsg.DiscardUnknown(m)
}

var xxx_messageInfo_BlockFetchRespMsg proto.InternalMessageInfo

func (m *BlockFetchRespMsg) GetStatus() BlockFetchStatus {
	if m != nil {
		return m.Status
	}
	return BlockFetchStatus_Succeeded
}

func (m *BlockFetchRespMsg) GetBlocks() []*BlockPair {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *BlockFetchRespMsg) GetAuthorIdx() uint64 {
	if m != nil {
		return m.AuthorIdx
	}
	return 0
}

type ConsensusPayload struct {
	Type MessageType `protobuf:"varint,1,opt,name=Type,proto3,enum=chainedbft.MessageType" json:"Type,omitempty"`
	// Types that are valid to be assigned to Data:
	//	*ConsensusPayload_ProposalMsg
	//	*ConsensusPayload_VoteMsg
	//	*ConsensusPayload_BlockFetchMsg
	//	*ConsensusPayload_BlockFetchRespMsg
	Data isConsensusPayload_Data `protobuf_oneof:"Data"`
}

func (m *ConsensusPayload) Reset()         { *m = ConsensusPayload{} }
func (m *ConsensusPayload) String() string { return proto.CompactTextString(m) }
func (*ConsensusPayload) ProtoMessage()    {}
func (*ConsensusPayload) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{10}
}
func (m *ConsensusPayload) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusPayload) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusPayload.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusPayload) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusPayload.Merge(m, src)
}
func (m *ConsensusPayload) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusPayload) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusPayload.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusPayload proto.InternalMessageInfo

type isConsensusPayload_Data interface {
	isConsensusPayload_Data()
	MarshalTo([]byte) (int, error)
	Size() int
}

type ConsensusPayload_ProposalMsg struct {
	ProposalMsg *ProposalMsg `protobuf:"bytes,2,opt,name=ProposalMsg,proto3,oneof" json:"ProposalMsg,omitempty"`
}
type ConsensusPayload_VoteMsg struct {
	VoteMsg *VoteMsg `protobuf:"bytes,3,opt,name=VoteMsg,proto3,oneof" json:"VoteMsg,omitempty"`
}
type ConsensusPayload_BlockFetchMsg struct {
	BlockFetchMsg *BlockFetchMsg `protobuf:"bytes,4,opt,name=BlockFetchMsg,proto3,oneof" json:"BlockFetchMsg,omitempty"`
}
type ConsensusPayload_BlockFetchRespMsg struct {
	BlockFetchRespMsg *BlockFetchRespMsg `protobuf:"bytes,5,opt,name=BlockFetchRespMsg,proto3,oneof" json:"BlockFetchRespMsg,omitempty"`
}

func (*ConsensusPayload_ProposalMsg) isConsensusPayload_Data()       {}
func (*ConsensusPayload_VoteMsg) isConsensusPayload_Data()           {}
func (*ConsensusPayload_BlockFetchMsg) isConsensusPayload_Data()     {}
func (*ConsensusPayload_BlockFetchRespMsg) isConsensusPayload_Data() {}

func (m *ConsensusPayload) GetData() isConsensusPayload_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ConsensusPayload) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return MessageType_ProposalMessage
}

func (m *ConsensusPayload) GetProposalMsg() *ProposalMsg {
	if x, ok := m.GetData().(*ConsensusPayload_ProposalMsg); ok {
		return x.ProposalMsg
	}
	return nil
}

func (m *ConsensusPayload) GetVoteMsg() *VoteMsg {
	if x, ok := m.GetData().(*ConsensusPayload_VoteMsg); ok {
		return x.VoteMsg
	}
	return nil
}

func (m *ConsensusPayload) GetBlockFetchMsg() *BlockFetchMsg {
	if x, ok := m.GetData().(*ConsensusPayload_BlockFetchMsg); ok {
		return x.BlockFetchMsg
	}
	return nil
}

func (m *ConsensusPayload) GetBlockFetchRespMsg() *BlockFetchRespMsg {
	if x, ok := m.GetData().(*ConsensusPayload_BlockFetchRespMsg); ok {
		return x.BlockFetchRespMsg
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*ConsensusPayload) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*ConsensusPayload_ProposalMsg)(nil),
		(*ConsensusPayload_VoteMsg)(nil),
		(*ConsensusPayload_BlockFetchMsg)(nil),
		(*ConsensusPayload_BlockFetchRespMsg)(nil),
	}
}

type ConsensusMsg struct {
	Payload   *ConsensusPayload        `protobuf:"bytes,1,opt,name=payload,proto3" json:"payload,omitempty"`
	SignEntry *common.EndorsementEntry `protobuf:"bytes,2,opt,name=SignEntry,proto3" json:"SignEntry,omitempty"`
}

func (m *ConsensusMsg) Reset()         { *m = ConsensusMsg{} }
func (m *ConsensusMsg) String() string { return proto.CompactTextString(m) }
func (*ConsensusMsg) ProtoMessage()    {}
func (*ConsensusMsg) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{11}
}
func (m *ConsensusMsg) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConsensusMsg) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConsensusMsg.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConsensusMsg) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConsensusMsg.Merge(m, src)
}
func (m *ConsensusMsg) XXX_Size() int {
	return m.Size()
}
func (m *ConsensusMsg) XXX_DiscardUnknown() {
	xxx_messageInfo_ConsensusMsg.DiscardUnknown(m)
}

var xxx_messageInfo_ConsensusMsg proto.InternalMessageInfo

func (m *ConsensusMsg) GetPayload() *ConsensusPayload {
	if m != nil {
		return m.Payload
	}
	return nil
}

func (m *ConsensusMsg) GetSignEntry() *common.EndorsementEntry {
	if m != nil {
		return m.SignEntry
	}
	return nil
}

type BuildProposal struct {
	Height     uint64 `protobuf:"varint,1,opt,name=Height,proto3" json:"Height,omitempty"`
	PreHash    []byte `protobuf:"bytes,2,opt,name=PreHash,proto3" json:"PreHash,omitempty"`
	IsProposer bool   `protobuf:"varint,3,opt,name=IsProposer,proto3" json:"IsProposer,omitempty"`
}

func (m *BuildProposal) Reset()         { *m = BuildProposal{} }
func (m *BuildProposal) String() string { return proto.CompactTextString(m) }
func (*BuildProposal) ProtoMessage()    {}
func (*BuildProposal) Descriptor() ([]byte, []int) {
	return fileDescriptor_4f12a9b7497e8ce5, []int{12}
}
func (m *BuildProposal) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BuildProposal) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BuildProposal.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BuildProposal) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildProposal.Merge(m, src)
}
func (m *BuildProposal) XXX_Size() int {
	return m.Size()
}
func (m *BuildProposal) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildProposal.DiscardUnknown(m)
}

var xxx_messageInfo_BuildProposal proto.InternalMessageInfo

func (m *BuildProposal) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BuildProposal) GetPreHash() []byte {
	if m != nil {
		return m.PreHash
	}
	return nil
}

func (m *BuildProposal) GetIsProposer() bool {
	if m != nil {
		return m.IsProposer
	}
	return false
}

func init() {
	proto.RegisterEnum("chainedbft.BlockFetchStatus", BlockFetchStatus_name, BlockFetchStatus_value)
	proto.RegisterEnum("chainedbft.ConsStateType", ConsStateType_name, ConsStateType_value)
	proto.RegisterEnum("chainedbft.MessageType", MessageType_name, MessageType_value)
	proto.RegisterType((*QuorumCert)(nil), "chainedbft.QuorumCert")
	proto.RegisterType((*ConsensusInfo)(nil), "chainedbft.ConsensusInfo")
	proto.RegisterType((*SyncInfo)(nil), "chainedbft.SyncInfo")
	proto.RegisterType((*ProposalData)(nil), "chainedbft.ProposalData")
	proto.RegisterType((*ProposalMsg)(nil), "chainedbft.ProposalMsg")
	proto.RegisterType((*VoteData)(nil), "chainedbft.VoteData")
	proto.RegisterType((*VoteMsg)(nil), "chainedbft.VoteMsg")
	proto.RegisterType((*BlockFetchMsg)(nil), "chainedbft.BlockFetchMsg")
	proto.RegisterType((*BlockPair)(nil), "chainedbft.BlockPair")
	proto.RegisterType((*BlockFetchRespMsg)(nil), "chainedbft.BlockFetchRespMsg")
	proto.RegisterType((*ConsensusPayload)(nil), "chainedbft.ConsensusPayload")
	proto.RegisterType((*ConsensusMsg)(nil), "chainedbft.ConsensusMsg")
	proto.RegisterType((*BuildProposal)(nil), "chainedbft.BuildProposal")
}

func init() {
	proto.RegisterFile("consensus/chainedbft/chainedbft.proto", fileDescriptor_4f12a9b7497e8ce5)
}

var fileDescriptor_4f12a9b7497e8ce5 = []byte{
	// 969 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x16, 0x25, 0x99, 0x92, 0x46, 0x92, 0xc3, 0x6e, 0x6c, 0x87, 0x31, 0x5c, 0x41, 0x60, 0xd1,
	0xc0, 0x70, 0x11, 0x29, 0x50, 0x8d, 0xf4, 0xd0, 0x5c, 0x62, 0xc5, 0x86, 0x54, 0x54, 0x82, 0xbc,
	0x36, 0x8c, 0xa2, 0x37, 0x9a, 0x5c, 0x53, 0x42, 0x24, 0xae, 0xca, 0x25, 0xeb, 0xea, 0x90, 0x3e,
	0x43, 0x4f, 0x3d, 0xf6, 0x29, 0xfa, 0x0e, 0xed, 0x31, 0xc7, 0x1e, 0x0b, 0xfb, 0x01, 0x7a, 0xe9,
	0x03, 0x14, 0xbb, 0x5c, 0xfe, 0x5a, 0xad, 0x6b, 0x20, 0x37, 0xce, 0xef, 0xce, 0x7c, 0xf3, 0xcd,
	0x48, 0xf0, 0xa9, 0x45, 0x5d, 0x46, 0x5c, 0x16, 0xb0, 0xae, 0x35, 0x35, 0x67, 0x2e, 0xb1, 0x2f,
	0xaf, 0xfc, 0xd4, 0x67, 0x67, 0xe9, 0x51, 0x9f, 0x22, 0x48, 0x34, 0xbb, 0xc8, 0xa2, 0x8b, 0x05,
	0x75, 0xbb, 0x97, 0x73, 0x6a, 0xbd, 0x0d, 0xed, 0xbb, 0x5b, 0x52, 0xe7, 0x91, 0xef, 0x02, 0xc2,
	0x64, 0x94, 0xf1, 0xab, 0x02, 0x70, 0x1a, 0x50, 0x2f, 0x58, 0xf4, 0x89, 0xe7, 0x23, 0x1d, 0x2a,
	0x47, 0x3c, 0x66, 0xf8, 0x46, 0x57, 0xda, 0xca, 0x7e, 0x03, 0x47, 0x22, 0xda, 0x01, 0x75, 0x40,
	0x66, 0xce, 0xd4, 0xd7, 0x8b, 0x6d, 0x65, 0xbf, 0x8c, 0xa5, 0x84, 0xb6, 0x60, 0xe3, 0x6b, 0xf2,
	0x3d, 0x99, 0xeb, 0x25, 0xa1, 0x0e, 0x05, 0x9e, 0x67, 0x4c, 0xae, 0x2f, 0x66, 0xe4, 0x5a, 0x2f,
	0xb7, 0x95, 0xfd, 0x2a, 0x8e, 0x44, 0x6e, 0x39, 0x5e, 0x52, 0x6b, 0x3a, 0xb4, 0xf5, 0x0d, 0x11,
	0x11, 0x89, 0xe8, 0x00, 0x36, 0x2e, 0xa8, 0x4f, 0x98, 0xae, 0xb6, 0x4b, 0xfb, 0xf5, 0xde, 0x56,
	0x27, 0xd5, 0x22, 0x37, 0xbc, 0x31, 0x7d, 0x13, 0x87, 0x2e, 0xc6, 0x17, 0xd0, 0xec, 0x47, 0xa8,
	0x0c, 0xdd, 0x2b, 0x8a, 0x9e, 0x41, 0xf1, 0xb4, 0x2f, 0x6a, 0xae, 0xf7, 0x76, 0xd2, 0x91, 0x49,
	0x73, 0xb8, 0x78, 0xda, 0x37, 0x7e, 0x51, 0xa0, 0x7a, 0xb6, 0x72, 0x2d, 0x11, 0x74, 0x08, 0xb5,
	0xc1, 0xcc, 0x99, 0x12, 0xe6, 0xdf, 0x1b, 0x9b, 0x38, 0xa6, 0xa2, 0xce, 0xfb, 0x02, 0x8c, 0xfb,
	0xa3, 0xce, 0xfb, 0xe8, 0x19, 0x6c, 0xc6, 0x42, 0x1a, 0xb0, 0x9c, 0xd6, 0xf8, 0x4b, 0x81, 0xc6,
	0xc4, 0xa3, 0x4b, 0xca, 0xcc, 0x39, 0xef, 0x18, 0x7d, 0x02, 0x1b, 0x62, 0x06, 0xb2, 0xc0, 0x66,
	0x27, 0x9c, 0x63, 0x47, 0x28, 0x71, 0x68, 0x7b, 0xe0, 0x74, 0x76, 0xa1, 0x1a, 0x3e, 0x41, 0x3c,
	0x31, 0x9e, 0x06, 0x8e, 0x65, 0xd4, 0x86, 0x7a, 0xf4, 0x3d, 0xb4, 0x7f, 0x90, 0x33, 0x4a, 0xab,
	0xd2, 0x13, 0x54, 0xb3, 0x13, 0x3c, 0x84, 0xda, 0x57, 0x01, 0xf3, 0x67, 0x57, 0xab, 0xd3, 0xbe,
	0x5e, 0xf9, 0x6f, 0x64, 0x62, 0x47, 0xe3, 0x5d, 0xf4, 0xa2, 0x39, 0x1f, 0x31, 0x07, 0xbd, 0xca,
	0xf6, 0x2f, 0xdb, 0xd6, 0xd3, 0x79, 0xd2, 0x76, 0x9c, 0x45, 0xeb, 0x45, 0x32, 0x5e, 0x39, 0x9b,
	0x0c, 0x8f, 0x22, 0x1b, 0x8e, 0xbd, 0x8c, 0xbf, 0x15, 0xa8, 0x46, 0xf4, 0xfa, 0x60, 0xfc, 0xdf,
	0x01, 0xf5, 0x75, 0xe0, 0x4f, 0x69, 0x84, 0xaf, 0x94, 0xd0, 0x1e, 0xd4, 0xc2, 0xaf, 0x04, 0xdb,
	0x44, 0x91, 0xde, 0x1a, 0xf5, 0x5f, 0xb7, 0xa6, 0x92, 0xc5, 0xfc, 0x25, 0xd4, 0xce, 0x66, 0x8e,
	0x6b, 0xfa, 0x81, 0x47, 0xf4, 0x6a, 0x84, 0x55, 0x48, 0x91, 0x63, 0xd7, 0xa6, 0x1e, 0x23, 0x0b,
	0xe2, 0xfa, 0xc7, 0xae, 0xef, 0xad, 0x70, 0xe2, 0x6a, 0x2c, 0xa0, 0xc2, 0xbb, 0xe6, 0x88, 0xbf,
	0x48, 0x00, 0x90, 0x68, 0xaf, 0xdf, 0xbd, 0x04, 0xa6, 0x87, 0xa3, 0xfc, 0x0e, 0x9a, 0x02, 0xc9,
	0x13, 0xe2, 0x5b, 0x53, 0xfe, 0xe8, 0xc3, 0x91, 0xde, 0x83, 0xda, 0x38, 0x58, 0x08, 0x2f, 0x26,
	0xd1, 0x4e, 0x14, 0x59, 0x64, 0xcb, 0x39, 0x64, 0x8d, 0x6f, 0xa0, 0x26, 0xfc, 0x26, 0xe6, 0xcc,
	0xfb, 0x7f, 0x1b, 0x15, 0x1e, 0x94, 0xe2, 0xbd, 0x07, 0xe5, 0x67, 0x05, 0x3e, 0x4a, 0x3a, 0xc3,
	0x84, 0x2d, 0x79, 0x77, 0x87, 0xa0, 0x9e, 0xf9, 0xa6, 0x1f, 0x30, 0xf1, 0xc6, 0x66, 0x6f, 0x2f,
	0x9d, 0x21, 0x71, 0x0f, 0x7d, 0xb0, 0xf4, 0x45, 0xcf, 0x41, 0x95, 0xed, 0x15, 0xc5, 0x09, 0xdc,
	0xbe, 0x13, 0xc5, 0xeb, 0xc7, 0xea, 0xba, 0x96, 0x4b, 0xf9, 0x96, 0x7f, 0x2b, 0x82, 0x16, 0xdf,
	0xc8, 0x89, 0xb9, 0x9a, 0x53, 0xd3, 0x46, 0x9f, 0x41, 0xf9, 0x7c, 0xb5, 0x24, 0xb2, 0xaa, 0x27,
	0xe9, 0xfc, 0x23, 0xc2, 0x98, 0xe9, 0x10, 0x6e, 0xc6, 0xc2, 0x09, 0x7d, 0x99, 0x59, 0x4c, 0x89,
	0xc5, 0x93, 0x75, 0x8b, 0x38, 0x62, 0xce, 0xa0, 0x80, 0x33, 0x6b, 0xdc, 0x8d, 0xf9, 0x25, 0x4a,
	0xab, 0xf7, 0x1e, 0xe7, 0x39, 0x15, 0x06, 0xc5, 0x2c, 0x7c, 0x9d, 0x63, 0x88, 0x18, 0x62, 0xbd,
	0xf7, 0x74, 0x3d, 0x72, 0x61, 0x70, 0x8e, 0x53, 0xa3, 0x35, 0xa3, 0x10, 0x5b, 0x56, 0xef, 0x7d,
	0xbc, 0x3e, 0x8d, 0x74, 0x1a, 0x14, 0xf0, 0xdd, 0xc8, 0x23, 0x15, 0xca, 0x9c, 0xed, 0xc6, 0x8f,
	0xd0, 0x88, 0x81, 0xe4, 0xcf, 0xbc, 0x84, 0xca, 0x32, 0xc4, 0x53, 0x32, 0x28, 0x33, 0xdd, 0x3c,
	0xe6, 0x38, 0x72, 0x8e, 0x56, 0x55, 0xac, 0xa2, 0x44, 0xf3, 0x9e, 0x55, 0x15, 0x9f, 0x86, 0x09,
	0xcd, 0xa3, 0x60, 0x36, 0xb7, 0x23, 0x78, 0x53, 0x1b, 0xa2, 0x64, 0x36, 0x44, 0x87, 0xca, 0xc4,
	0x23, 0x03, 0x93, 0x4d, 0x45, 0xfa, 0x06, 0x8e, 0x44, 0xd4, 0x02, 0x18, 0xb2, 0xf8, 0xe6, 0x97,
	0xc4, 0x71, 0x49, 0x69, 0x0e, 0x4e, 0x40, 0xcb, 0xb3, 0x12, 0x35, 0xa1, 0x76, 0x16, 0x58, 0x16,
	0x21, 0x36, 0xb1, 0xb5, 0x02, 0xda, 0x04, 0x18, 0xda, 0x63, 0xea, 0x9f, 0xd0, 0xc0, 0xb5, 0x35,
	0x05, 0x3d, 0x86, 0x47, 0x63, 0xea, 0x1f, 0xbb, 0x34, 0x70, 0xa6, 0x21, 0x21, 0xb5, 0xe2, 0x01,
	0x0e, 0x7f, 0x97, 0x79, 0x06, 0xc1, 0x24, 0x9e, 0x64, 0x4c, 0xae, 0xc3, 0xfa, 0xb4, 0x02, 0x6a,
	0x40, 0x75, 0x4c, 0xae, 0xc5, 0x8d, 0xd4, 0x14, 0x54, 0xe7, 0xf5, 0x8a, 0x0a, 0xb4, 0x22, 0xaa,
	0x42, 0x99, 0x53, 0x41, 0x2b, 0xf1, 0x98, 0x89, 0x69, 0x91, 0x91, 0xf9, 0x96, 0x78, 0x5a, 0xf9,
	0x80, 0x40, 0x3d, 0xc5, 0x4d, 0xfe, 0x6e, 0xcc, 0xb3, 0x50, 0xad, 0x15, 0xd0, 0x23, 0xa8, 0x0b,
	0x1e, 0x49, 0x85, 0x82, 0xb6, 0xd3, 0x54, 0x88, 0xd4, 0x45, 0xf4, 0x14, 0xb6, 0x73, 0x73, 0x96,
	0xa6, 0xd2, 0xd1, 0xc5, 0xef, 0x37, 0x2d, 0xe5, 0xfd, 0x4d, 0x4b, 0xf9, 0xf3, 0xa6, 0xa5, 0xfc,
	0x74, 0xdb, 0x2a, 0xbc, 0xbf, 0x6d, 0x15, 0xfe, 0xb8, 0x6d, 0x15, 0xbe, 0x7d, 0x25, 0xa6, 0xbb,
	0xe0, 0xe5, 0x74, 0xa8, 0xe7, 0x74, 0x13, 0xf1, 0xb9, 0x43, 0xbb, 0xcb, 0xcb, 0xae, 0xf8, 0x2b,
	0xe5, 0xd0, 0xee, 0xba, 0x3f, 0x6a, 0x97, 0xaa, 0xb0, 0x7e, 0xfe, 0x4f, 0x00, 0x00, 0x00, 0xff,
	0xff, 0xb0, 0x8a, 0xfa, 0x50, 0xc7, 0x09, 0x00, 0x00,
}

func (m *QuorumCert) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *QuorumCert) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *QuorumCert) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Votes) > 0 {
		for iNdEx := len(m.Votes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Votes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainedbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x32
		}
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x28
	}
	if m.NewView {
		i--
		if m.NewView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QC != nil {
		{
			size, err := m.QC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SyncInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SyncInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SyncInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.HighestTCLevel != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.HighestTCLevel))
		i--
		dAtA[i] = 0x18
	}
	if m.HighestTC != nil {
		{
			size, err := m.HighestTC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.HighestQC != nil {
		{
			size, err := m.HighestQC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.JustifyQC != nil {
		{
			size, err := m.JustifyQC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x30
	}
	if m.ProposerIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.ProposerIdx))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Proposer) > 0 {
		i -= len(m.Proposer)
		copy(dAtA[i:], m.Proposer)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.Proposer)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ProposalMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SyncInfo != nil {
		{
			size, err := m.SyncInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.ProposalData != nil {
		{
			size, err := m.ProposalData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Signature != nil {
		{
			size, err := m.Signature.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.EpochId != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.EpochId))
		i--
		dAtA[i] = 0x38
	}
	if m.NewView {
		i--
		if m.NewView {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Author) > 0 {
		i -= len(m.Author)
		copy(dAtA[i:], m.Author)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.Author)))
		i--
		dAtA[i] = 0x22
	}
	if m.Level != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Level))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *VoteMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *VoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SyncInfo != nil {
		{
			size, err := m.SyncInfo.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.VoteData != nil {
		{
			size, err := m.VoteData.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockFetchMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockFetchMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockFetchMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x20
	}
	if m.NumBlocks != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.NumBlocks))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.BlockID) > 0 {
		i -= len(m.BlockID)
		copy(dAtA[i:], m.BlockID)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.BlockID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockPair) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockPair) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockPair) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.QC != nil {
		{
			size, err := m.QC.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Block != nil {
		{
			size, err := m.Block.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BlockFetchRespMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockFetchRespMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockFetchRespMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AuthorIdx != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.AuthorIdx))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintChainedbft(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if m.Status != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusPayload) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusPayload) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data != nil {
		{
			size := m.Data.Size()
			i -= size
			if _, err := m.Data.MarshalTo(dAtA[i:]); err != nil {
				return 0, err
			}
		}
	}
	if m.Type != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ConsensusPayload_ProposalMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_ProposalMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.ProposalMsg != nil {
		{
			size, err := m.ProposalMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_VoteMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_VoteMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.VoteMsg != nil {
		{
			size, err := m.VoteMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_BlockFetchMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_BlockFetchMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockFetchMsg != nil {
		{
			size, err := m.BlockFetchMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusPayload_BlockFetchRespMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusPayload_BlockFetchRespMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	if m.BlockFetchRespMsg != nil {
		{
			size, err := m.BlockFetchRespMsg.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x2a
	}
	return len(dAtA) - i, nil
}
func (m *ConsensusMsg) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConsensusMsg) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ConsensusMsg) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SignEntry != nil {
		{
			size, err := m.SignEntry.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Payload != nil {
		{
			size, err := m.Payload.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintChainedbft(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *BuildProposal) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BuildProposal) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BuildProposal) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsProposer {
		i--
		if m.IsProposer {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if len(m.PreHash) > 0 {
		i -= len(m.PreHash)
		copy(dAtA[i:], m.PreHash)
		i = encodeVarintChainedbft(dAtA, i, uint64(len(m.PreHash)))
		i--
		dAtA[i] = 0x12
	}
	if m.Height != 0 {
		i = encodeVarintChainedbft(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintChainedbft(dAtA []byte, offset int, v uint64) int {
	offset -= sovChainedbft(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *QuorumCert) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	if m.NewView {
		n += 2
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if len(m.Votes) > 0 {
		for _, e := range m.Votes {
			l = e.Size()
			n += 1 + l + sovChainedbft(uint64(l))
		}
	}
	return n
}

func (m *ConsensusInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.QC != nil {
		l = m.QC.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *SyncInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HighestQC != nil {
		l = m.HighestQC.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.HighestTC != nil {
		l = m.HighestTC.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.HighestTCLevel != 0 {
		n += 1 + sovChainedbft(uint64(m.HighestTCLevel))
	}
	return n
}

func (m *ProposalData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	l = len(m.Proposer)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.ProposerIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.ProposerIdx))
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if m.JustifyQC != nil {
		l = m.JustifyQC.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *ProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalData != nil {
		l = m.ProposalData.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SyncInfo != nil {
		l = m.SyncInfo.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *VoteData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.Level != 0 {
		n += 1 + sovChainedbft(uint64(m.Level))
	}
	l = len(m.Author)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	if m.NewView {
		n += 2
	}
	if m.EpochId != 0 {
		n += 1 + sovChainedbft(uint64(m.EpochId))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteData != nil {
		l = m.VoteData.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SyncInfo != nil {
		l = m.SyncInfo.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BlockFetchMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.BlockID)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	if m.NumBlocks != 0 {
		n += 1 + sovChainedbft(uint64(m.NumBlocks))
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	return n
}

func (m *BlockPair) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Block != nil {
		l = m.Block.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.QC != nil {
		l = m.QC.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BlockFetchRespMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Status != 0 {
		n += 1 + sovChainedbft(uint64(m.Status))
	}
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovChainedbft(uint64(l))
		}
	}
	if m.AuthorIdx != 0 {
		n += 1 + sovChainedbft(uint64(m.AuthorIdx))
	}
	return n
}

func (m *ConsensusPayload) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Type != 0 {
		n += 1 + sovChainedbft(uint64(m.Type))
	}
	if m.Data != nil {
		n += m.Data.Size()
	}
	return n
}

func (m *ConsensusPayload_ProposalMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ProposalMsg != nil {
		l = m.ProposalMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_VoteMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VoteMsg != nil {
		l = m.VoteMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_BlockFetchMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockFetchMsg != nil {
		l = m.BlockFetchMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusPayload_BlockFetchRespMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BlockFetchRespMsg != nil {
		l = m.BlockFetchRespMsg.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}
func (m *ConsensusMsg) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Payload != nil {
		l = m.Payload.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.SignEntry != nil {
		l = m.SignEntry.Size()
		n += 1 + l + sovChainedbft(uint64(l))
	}
	return n
}

func (m *BuildProposal) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Height != 0 {
		n += 1 + sovChainedbft(uint64(m.Height))
	}
	l = len(m.PreHash)
	if l > 0 {
		n += 1 + l + sovChainedbft(uint64(l))
	}
	if m.IsProposer {
		n += 2
	}
	return n
}

func sovChainedbft(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozChainedbft(x uint64) (n int) {
	return sovChainedbft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *QuorumCert) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: QuorumCert: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: QuorumCert: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = append(m.BlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockID == nil {
				m.BlockID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewView = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Votes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Votes = append(m.Votes, &VoteData{})
			if err := m.Votes[len(m.Votes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QC == nil {
				m.QC = &QuorumCert{}
			}
			if err := m.QC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SyncInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SyncInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SyncInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestQC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestQC == nil {
				m.HighestQC = &QuorumCert{}
			}
			if err := m.HighestQC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestTC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.HighestTC == nil {
				m.HighestTC = &QuorumCert{}
			}
			if err := m.HighestTC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HighestTCLevel", wireType)
			}
			m.HighestTCLevel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HighestTCLevel |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proposer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proposer = append(m.Proposer[:0], dAtA[iNdEx:postIndex]...)
			if m.Proposer == nil {
				m.Proposer = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerIdx", wireType)
			}
			m.ProposerIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ProposerIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JustifyQC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.JustifyQC == nil {
				m.JustifyQC = &QuorumCert{}
			}
			if err := m.JustifyQC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ProposalMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ProposalMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ProposalMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ProposalData == nil {
				m.ProposalData = &ProposalData{}
			}
			if err := m.ProposalData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncInfo == nil {
				m.SyncInfo = &SyncInfo{}
			}
			if err := m.SyncInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = append(m.BlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockID == nil {
				m.BlockID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Level", wireType)
			}
			m.Level = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Level |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Author", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Author = append(m.Author[:0], dAtA[iNdEx:postIndex]...)
			if m.Author == nil {
				m.Author = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewView", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NewView = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochId", wireType)
			}
			m.EpochId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &common.EndorsementEntry{}
			}
			if err := m.Signature.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VoteMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VoteMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VoteMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteData", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VoteData == nil {
				m.VoteData = &VoteData{}
			}
			if err := m.VoteData.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SyncInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SyncInfo == nil {
				m.SyncInfo = &SyncInfo{}
			}
			if err := m.SyncInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockFetchMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockFetchMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockFetchMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockID", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BlockID = append(m.BlockID[:0], dAtA[iNdEx:postIndex]...)
			if m.BlockID == nil {
				m.BlockID = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBlocks", wireType)
			}
			m.NumBlocks = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBlocks |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockPair) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockPair: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockPair: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Block", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Block == nil {
				m.Block = &common.Block{}
			}
			if err := m.Block.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field QC", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.QC == nil {
				m.QC = &QuorumCert{}
			}
			if err := m.QC.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BlockFetchRespMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockFetchRespMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockFetchRespMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BlockFetchStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &BlockPair{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthorIdx", wireType)
			}
			m.AuthorIdx = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthorIdx |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusPayload) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusPayload: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusPayload: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposalMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &ProposalMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_ProposalMsg{v}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VoteMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &VoteMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_VoteMsg{v}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFetchMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockFetchMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_BlockFetchMsg{v}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockFetchRespMsg", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			v := &BlockFetchRespMsg{}
			if err := v.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			m.Data = &ConsensusPayload_BlockFetchRespMsg{v}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ConsensusMsg) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConsensusMsg: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConsensusMsg: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Payload", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Payload == nil {
				m.Payload = &ConsensusPayload{}
			}
			if err := m.Payload.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SignEntry", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SignEntry == nil {
				m.SignEntry = &common.EndorsementEntry{}
			}
			if err := m.SignEntry.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BuildProposal) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BuildProposal: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BuildProposal: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthChainedbft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthChainedbft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreHash = append(m.PreHash[:0], dAtA[iNdEx:postIndex]...)
			if m.PreHash == nil {
				m.PreHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsProposer", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsProposer = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipChainedbft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthChainedbft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipChainedbft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowChainedbft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowChainedbft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthChainedbft
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupChainedbft
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthChainedbft
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthChainedbft        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowChainedbft          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupChainedbft = fmt.Errorf("proto: unexpected end of group")
)
