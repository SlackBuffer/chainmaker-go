// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: common/contract.proto

package common

import (
	accesscontrol "chainmaker.org/chainmaker-go/pb/protogo/accesscontrol"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type ContractName int32

const (
	// system chain configuration contract
	// used to add, delete and change the chain configuration
	ContractName_SYSTEM_CONTRACT_CHAIN_CONFIG ContractName = 0
	// system chain query contract
	// used to query the configuration on the chain
	ContractName_SYSTEM_CONTRACT_QUERY ContractName = 1
	// system certificate storage contract
	// used to manage certificates
	ContractName_SYSTEM_CONTRACT_CERT_MANAGE ContractName = 2
	// governance contract
	ContractName_SYSTEM_CONTRACT_GOVERNANCE ContractName = 3
	// multi signature contract on chain
	ContractName_SYSTEM_CONTRACT_MULTI_SIGN ContractName = 4
	// contract state
	ContractName_SYSTEM_CONTRACT_STATE ContractName = 5
	// private compute contract
	ContractName_SYSTEM_CONTRACT_PRIVATE_COMPUTE ContractName = 6
	// erc20 contract for DPoS
	ContractName_SYSTEM_CONTRACT_DPOS_ERC20 ContractName = 7
	// stake contract for dpos
	ContractName_SYSTEM_CONTRACT_DPOS_STAKE ContractName = 8
)

var ContractName_name = map[int32]string{
	0: "SYSTEM_CONTRACT_CHAIN_CONFIG",
	1: "SYSTEM_CONTRACT_QUERY",
	2: "SYSTEM_CONTRACT_CERT_MANAGE",
	3: "SYSTEM_CONTRACT_GOVERNANCE",
	4: "SYSTEM_CONTRACT_MULTI_SIGN",
	5: "SYSTEM_CONTRACT_STATE",
	6: "SYSTEM_CONTRACT_PRIVATE_COMPUTE",
	7: "SYSTEM_CONTRACT_DPOS_ERC20",
	8: "SYSTEM_CONTRACT_DPOS_STAKE",
}

var ContractName_value = map[string]int32{
	"SYSTEM_CONTRACT_CHAIN_CONFIG":    0,
	"SYSTEM_CONTRACT_QUERY":           1,
	"SYSTEM_CONTRACT_CERT_MANAGE":     2,
	"SYSTEM_CONTRACT_GOVERNANCE":      3,
	"SYSTEM_CONTRACT_MULTI_SIGN":      4,
	"SYSTEM_CONTRACT_STATE":           5,
	"SYSTEM_CONTRACT_PRIVATE_COMPUTE": 6,
	"SYSTEM_CONTRACT_DPOS_ERC20":      7,
	"SYSTEM_CONTRACT_DPOS_STAKE":      8,
}

func (x ContractName) String() string {
	return proto.EnumName(ContractName_name, int32(x))
}

func (ContractName) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}

type QueryFunction int32

const (
	// get block by transactionId
	QueryFunction_GET_BLOCK_BY_TX_ID QueryFunction = 0
	// get contract information
	QueryFunction_GET_CONTRACT_INFO QueryFunction = 1
	// get transaction by transactionId
	QueryFunction_GET_TX_BY_TX_ID QueryFunction = 2
	// get block by block height
	QueryFunction_GET_BLOCK_BY_HEIGHT QueryFunction = 3
	// get chain information
	QueryFunction_GET_CHAIN_INFO QueryFunction = 4
	// get the last configuration block
	QueryFunction_GET_LAST_CONFIG_BLOCK QueryFunction = 5
	// get block by block hash
	QueryFunction_GET_BLOCK_BY_HASH QueryFunction = 6
	// get the list of node
	QueryFunction_GET_NODE_CHAIN_LIST QueryFunction = 7
	// get governance information
	QueryFunction_GET_GOVERNANCE_CONTRACT QueryFunction = 8
	// get read/write set information by eight
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT QueryFunction = 9
	// get read/write set information by hash
	QueryFunction_GET_BLOCK_WITH_TXRWSETS_BY_HASH QueryFunction = 10
	// get the last block
	QueryFunction_GET_LAST_BLOCK QueryFunction = 11
	// get full block by height
	QueryFunction_GET_FULL_BLOCK_BY_HEIGHT QueryFunction = 12
	// get block height by tx id
	QueryFunction_GET_BLOCK_HEIGHT_BY_TX_ID QueryFunction = 13
	// get block height by hash
	QueryFunction_GET_BLOCK_HEIGHT_BY_HASH QueryFunction = 14
	//get block header by height
	QueryFunction_GET_BLOCK_HEADER_BY_HEIGHT QueryFunction = 15
	// get archived block height
	QueryFunction_GET_ARCHIVED_BLOCK_HEIGHT QueryFunction = 16
	//get contract bytecode
	QueryFunction_GET_CONTRACT_BYTECODE QueryFunction = 17
	//get all contract info list
	QueryFunction_GET_ALL_CONTRACTS QueryFunction = 18
)

var QueryFunction_name = map[int32]string{
	0:  "GET_BLOCK_BY_TX_ID",
	1:  "GET_CONTRACT_INFO",
	2:  "GET_TX_BY_TX_ID",
	3:  "GET_BLOCK_BY_HEIGHT",
	4:  "GET_CHAIN_INFO",
	5:  "GET_LAST_CONFIG_BLOCK",
	6:  "GET_BLOCK_BY_HASH",
	7:  "GET_NODE_CHAIN_LIST",
	8:  "GET_GOVERNANCE_CONTRACT",
	9:  "GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT",
	10: "GET_BLOCK_WITH_TXRWSETS_BY_HASH",
	11: "GET_LAST_BLOCK",
	12: "GET_FULL_BLOCK_BY_HEIGHT",
	13: "GET_BLOCK_HEIGHT_BY_TX_ID",
	14: "GET_BLOCK_HEIGHT_BY_HASH",
	15: "GET_BLOCK_HEADER_BY_HEIGHT",
	16: "GET_ARCHIVED_BLOCK_HEIGHT",
	17: "GET_CONTRACT_BYTECODE",
	18: "GET_ALL_CONTRACTS",
}

var QueryFunction_value = map[string]int32{
	"GET_BLOCK_BY_TX_ID":                0,
	"GET_CONTRACT_INFO":                 1,
	"GET_TX_BY_TX_ID":                   2,
	"GET_BLOCK_BY_HEIGHT":               3,
	"GET_CHAIN_INFO":                    4,
	"GET_LAST_CONFIG_BLOCK":             5,
	"GET_BLOCK_BY_HASH":                 6,
	"GET_NODE_CHAIN_LIST":               7,
	"GET_GOVERNANCE_CONTRACT":           8,
	"GET_BLOCK_WITH_TXRWSETS_BY_HEIGHT": 9,
	"GET_BLOCK_WITH_TXRWSETS_BY_HASH":   10,
	"GET_LAST_BLOCK":                    11,
	"GET_FULL_BLOCK_BY_HEIGHT":          12,
	"GET_BLOCK_HEIGHT_BY_TX_ID":         13,
	"GET_BLOCK_HEIGHT_BY_HASH":          14,
	"GET_BLOCK_HEADER_BY_HEIGHT":        15,
	"GET_ARCHIVED_BLOCK_HEIGHT":         16,
	"GET_CONTRACT_BYTECODE":             17,
	"GET_ALL_CONTRACTS":                 18,
}

func (x QueryFunction) String() string {
	return proto.EnumName(QueryFunction_name, int32(x))
}

func (QueryFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}

// smart contract runtime, contains vm type and language type
type RuntimeType int32

const (
	RuntimeType_INVALID RuntimeType = 0
	// native implement in chainmaker-go
	RuntimeType_NATIVE RuntimeType = 1
	// vm-wasmer, language-c++
	RuntimeType_WASMER RuntimeType = 2
	// vm-wxvm, language-cpp
	RuntimeType_WXVM RuntimeType = 3
	// wasm interpreter in go
	RuntimeType_GASM RuntimeType = 4
	// vm-evm
	RuntimeType_EVM RuntimeType = 5
	// vm-docker, language-golang
	RuntimeType_DOCKER_GO RuntimeType = 6
	// vm-docker, language-java
	RuntimeType_DOCKER_JAVA RuntimeType = 7
)

var RuntimeType_name = map[int32]string{
	0: "INVALID",
	1: "NATIVE",
	2: "WASMER",
	3: "WXVM",
	4: "GASM",
	5: "EVM",
	6: "DOCKER_GO",
	7: "DOCKER_JAVA",
}

var RuntimeType_value = map[string]int32{
	"INVALID":     0,
	"NATIVE":      1,
	"WASMER":      2,
	"WXVM":        3,
	"GASM":        4,
	"EVM":         5,
	"DOCKER_GO":   6,
	"DOCKER_JAVA": 7,
}

func (x RuntimeType) String() string {
	return proto.EnumName(RuntimeType_name, int32(x))
}

func (RuntimeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}

type ConfigFunction int32

const (
	// get chain configuration
	ConfigFunction_GET_CHAIN_CONFIG ConfigFunction = 0
	// get the latest configuration block
	// the incoming blockheight must exist in the database
	// 如果传入的blockHeight是配置块，直接返回当前的配置信息
	ConfigFunction_GET_CHAIN_CONFIG_AT ConfigFunction = 1
	// update core
	ConfigFunction_CORE_UPDATE ConfigFunction = 2
	// update block
	ConfigFunction_BLOCK_UPDATE ConfigFunction = 3
	// add trusted certficate (org_id and root)
	ConfigFunction_TRUST_ROOT_ADD ConfigFunction = 4
	// [self] modify an individual's own trusted root certificate [org_id must exist in the original trust_roots,
	// and the new root certificate must be different from other certificates]
	ConfigFunction_TRUST_ROOT_UPDATE ConfigFunction = 5
	// delete trusted root certificate [org_ ID should be in trust_ The nodes in nodes need to be deleted]
	ConfigFunction_TRUST_ROOT_DELETE ConfigFunction = 6
	// organization add node address
	// org_id must already exist in nodes，you can add addresses in batches
	// the parameter is addresses. Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	// Deprecated , replace by NODE_ID_ADD
	ConfigFunction_NODE_ADDR_ADD ConfigFunction = 7
	// [self]the organization updates an address
	//[org_id and address must already exist in nodes, new_address is the new address. ip+port and peerId cannot be duplicated]
	// Deprecated , replace by NODE_ID_UPDATE
	ConfigFunction_NODE_ADDR_UPDATE ConfigFunction = 8
	// organization delete node address [org_id and address must already exist in nodes]
	// Deprecated , replace by NODE_ID_DELETE
	ConfigFunction_NODE_ADDR_DELETE ConfigFunction = 9
	// organization add node address in batches [org_id在nodes不存在，批量添加地址，参数为node_ids，单地址用逗号","隔开。nodeId不能重复]
	ConfigFunction_NODE_ORG_ADD ConfigFunction = 10
	// organization update
	// org_id must already exist in nodes，the parameter is addresses，Single addresses are separated by ","
	// ip+port and peerid cannot be repeated
	ConfigFunction_NODE_ORG_UPDATE ConfigFunction = 11
	// organization delete, org_id must already exist in nodes
	ConfigFunction_NODE_ORG_DELETE ConfigFunction = 12
	// add consensus parameters, key is not exit in ext_config
	ConfigFunction_CONSENSUS_EXT_ADD ConfigFunction = 13
	// update onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_UPDATE ConfigFunction = 14
	// delete onsensus parameters, key exit in ext_config
	ConfigFunction_CONSENSUS_EXT_DELETE ConfigFunction = 15
	// add permission
	ConfigFunction_PERMISSION_ADD ConfigFunction = 16
	// update permission
	ConfigFunction_PERMISSION_UPDATE ConfigFunction = 17
	// delete permission
	ConfigFunction_PERMISSION_DELETE ConfigFunction = 18
	// organization add node_id
	// org_id must already exist in nodes，you can add node_id in batches
	// the parameter is node_ids. Single node_ids are separated by ","
	// node_id cannot be repeated
	ConfigFunction_NODE_ID_ADD ConfigFunction = 19
	// [self]the organization updates a node_ids
	//[org_id and node_ids must already exist in nodes, new_node_id is the new node_id. node_id cannot be duplicated]
	ConfigFunction_NODE_ID_UPDATE ConfigFunction = 20
	// organization delete node_id [org_id and node_id must already exist in nodes]
	ConfigFunction_NODE_ID_DELETE ConfigFunction = 21
)

var ConfigFunction_name = map[int32]string{
	0:  "GET_CHAIN_CONFIG",
	1:  "GET_CHAIN_CONFIG_AT",
	2:  "CORE_UPDATE",
	3:  "BLOCK_UPDATE",
	4:  "TRUST_ROOT_ADD",
	5:  "TRUST_ROOT_UPDATE",
	6:  "TRUST_ROOT_DELETE",
	7:  "NODE_ADDR_ADD",
	8:  "NODE_ADDR_UPDATE",
	9:  "NODE_ADDR_DELETE",
	10: "NODE_ORG_ADD",
	11: "NODE_ORG_UPDATE",
	12: "NODE_ORG_DELETE",
	13: "CONSENSUS_EXT_ADD",
	14: "CONSENSUS_EXT_UPDATE",
	15: "CONSENSUS_EXT_DELETE",
	16: "PERMISSION_ADD",
	17: "PERMISSION_UPDATE",
	18: "PERMISSION_DELETE",
	19: "NODE_ID_ADD",
	20: "NODE_ID_UPDATE",
	21: "NODE_ID_DELETE",
}

var ConfigFunction_value = map[string]int32{
	"GET_CHAIN_CONFIG":     0,
	"GET_CHAIN_CONFIG_AT":  1,
	"CORE_UPDATE":          2,
	"BLOCK_UPDATE":         3,
	"TRUST_ROOT_ADD":       4,
	"TRUST_ROOT_UPDATE":    5,
	"TRUST_ROOT_DELETE":    6,
	"NODE_ADDR_ADD":        7,
	"NODE_ADDR_UPDATE":     8,
	"NODE_ADDR_DELETE":     9,
	"NODE_ORG_ADD":         10,
	"NODE_ORG_UPDATE":      11,
	"NODE_ORG_DELETE":      12,
	"CONSENSUS_EXT_ADD":    13,
	"CONSENSUS_EXT_UPDATE": 14,
	"CONSENSUS_EXT_DELETE": 15,
	"PERMISSION_ADD":       16,
	"PERMISSION_UPDATE":    17,
	"PERMISSION_DELETE":    18,
	"NODE_ID_ADD":          19,
	"NODE_ID_UPDATE":       20,
	"NODE_ID_DELETE":       21,
}

func (x ConfigFunction) String() string {
	return proto.EnumName(ConfigFunction_name, int32(x))
}

func (ConfigFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{3}
}

// Methods of certificate management
type CertManageFunction int32

const (
	// add certficate
	CertManageFunction_CERT_ADD CertManageFunction = 0
	// delete certficate
	CertManageFunction_CERTS_DELETE CertManageFunction = 1
	// query certficate
	CertManageFunction_CERTS_QUERY CertManageFunction = 2
	// freeze certificate
	CertManageFunction_CERTS_FREEZE CertManageFunction = 3
	// unfreezing certificate
	CertManageFunction_CERTS_UNFREEZE CertManageFunction = 4
	// Revocation of certificate
	CertManageFunction_CERTS_REVOKE CertManageFunction = 5
)

var CertManageFunction_name = map[int32]string{
	0: "CERT_ADD",
	1: "CERTS_DELETE",
	2: "CERTS_QUERY",
	3: "CERTS_FREEZE",
	4: "CERTS_UNFREEZE",
	5: "CERTS_REVOKE",
}

var CertManageFunction_value = map[string]int32{
	"CERT_ADD":       0,
	"CERTS_DELETE":   1,
	"CERTS_QUERY":    2,
	"CERTS_FREEZE":   3,
	"CERTS_UNFREEZE": 4,
	"CERTS_REVOKE":   5,
}

func (x CertManageFunction) String() string {
	return proto.EnumName(CertManageFunction_name, int32(x))
}

func (CertManageFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{4}
}

// methods of managing multi signature
type MultiSignFunction int32

const (
	// multi signature request
	MultiSignFunction_REQ MultiSignFunction = 0
	// multi signature voting
	MultiSignFunction_VOTE MultiSignFunction = 1
	// multi signature query
	MultiSignFunction_QUERY MultiSignFunction = 2
)

var MultiSignFunction_name = map[int32]string{
	0: "REQ",
	1: "VOTE",
	2: "QUERY",
}

var MultiSignFunction_value = map[string]int32{
	"REQ":   0,
	"VOTE":  1,
	"QUERY": 2,
}

func (x MultiSignFunction) String() string {
	return proto.EnumName(MultiSignFunction_name, int32(x))
}

func (MultiSignFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{5}
}

// methods of user management contract
type ManageUserContractFunction int32

const (
	// init contract
	ManageUserContractFunction_INIT_CONTRACT ManageUserContractFunction = 0
	// upgrade contract
	ManageUserContractFunction_UPGRADE_CONTRACT ManageUserContractFunction = 1
	// freeze  contract
	ManageUserContractFunction_FREEZE_CONTRACT ManageUserContractFunction = 2
	// unfreezing contract
	ManageUserContractFunction_UNFREEZE_CONTRACT ManageUserContractFunction = 3
	// Revocation of contract
	ManageUserContractFunction_REVOKE_CONTRACT ManageUserContractFunction = 4
)

var ManageUserContractFunction_name = map[int32]string{
	0: "INIT_CONTRACT",
	1: "UPGRADE_CONTRACT",
	2: "FREEZE_CONTRACT",
	3: "UNFREEZE_CONTRACT",
	4: "REVOKE_CONTRACT",
}

var ManageUserContractFunction_value = map[string]int32{
	"INIT_CONTRACT":     0,
	"UPGRADE_CONTRACT":  1,
	"FREEZE_CONTRACT":   2,
	"UNFREEZE_CONTRACT": 3,
	"REVOKE_CONTRACT":   4,
}

func (x ManageUserContractFunction) String() string {
	return proto.EnumName(ManageUserContractFunction_name, int32(x))
}

func (ManageUserContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{6}
}

// methods of private compute contract
type PrivateComputeContractFunction int32

const (
	// get contract code
	PrivateComputeContractFunction_GET_CONTRACT PrivateComputeContractFunction = 0
	// get private data
	PrivateComputeContractFunction_GET_DATA PrivateComputeContractFunction = 1
	// save cert of tee
	PrivateComputeContractFunction_SAVE_CA_CERT PrivateComputeContractFunction = 2
	// save private data dir
	PrivateComputeContractFunction_SAVE_DIR PrivateComputeContractFunction = 3
	// save data of private computation result
	PrivateComputeContractFunction_SAVE_DATA PrivateComputeContractFunction = 4
	//save contract code
	PrivateComputeContractFunction_SAVE_CONTRACT PrivateComputeContractFunction = 5
	//save enclave report
	PrivateComputeContractFunction_SAVE_ENCLAVE_REPORT PrivateComputeContractFunction = 6
	//get enclave proof
	PrivateComputeContractFunction_GET_ENCLAVE_PROOF PrivateComputeContractFunction = 7
	//get cert of tee
	PrivateComputeContractFunction_GET_CA_CERT PrivateComputeContractFunction = 8
	//get private data dir
	PrivateComputeContractFunction_GET_DIR PrivateComputeContractFunction = 9
	//update contract
	PrivateComputeContractFunction_UPDATE_CONTRACT PrivateComputeContractFunction = 10
	//checkCallerCertAuth
	PrivateComputeContractFunction_CHECK_CALLER_CERT_AUTH           PrivateComputeContractFunction = 11
	PrivateComputeContractFunction_GET_ENCLAVE_ENCRYPT_PUB_KEY      PrivateComputeContractFunction = 12
	PrivateComputeContractFunction_GET_ENCLAVE_VERIFICATION_PUB_KEY PrivateComputeContractFunction = 13
	PrivateComputeContractFunction_GET_ENCLAVE_REPORT               PrivateComputeContractFunction = 14
	PrivateComputeContractFunction_GET_ENCLAVE_CHALLENGE            PrivateComputeContractFunction = 15
	PrivateComputeContractFunction_GET_ENCLAVE_SIGNATURE            PrivateComputeContractFunction = 16
	PrivateComputeContractFunction_SAVE_REMOTE_ATTESTATION          PrivateComputeContractFunction = 17
)

var PrivateComputeContractFunction_name = map[int32]string{
	0:  "GET_CONTRACT",
	1:  "GET_DATA",
	2:  "SAVE_CA_CERT",
	3:  "SAVE_DIR",
	4:  "SAVE_DATA",
	5:  "SAVE_CONTRACT",
	6:  "SAVE_ENCLAVE_REPORT",
	7:  "GET_ENCLAVE_PROOF",
	8:  "GET_CA_CERT",
	9:  "GET_DIR",
	10: "UPDATE_CONTRACT",
	11: "CHECK_CALLER_CERT_AUTH",
	12: "GET_ENCLAVE_ENCRYPT_PUB_KEY",
	13: "GET_ENCLAVE_VERIFICATION_PUB_KEY",
	14: "GET_ENCLAVE_REPORT",
	15: "GET_ENCLAVE_CHALLENGE",
	16: "GET_ENCLAVE_SIGNATURE",
	17: "SAVE_REMOTE_ATTESTATION",
}

var PrivateComputeContractFunction_value = map[string]int32{
	"GET_CONTRACT":                     0,
	"GET_DATA":                         1,
	"SAVE_CA_CERT":                     2,
	"SAVE_DIR":                         3,
	"SAVE_DATA":                        4,
	"SAVE_CONTRACT":                    5,
	"SAVE_ENCLAVE_REPORT":              6,
	"GET_ENCLAVE_PROOF":                7,
	"GET_CA_CERT":                      8,
	"GET_DIR":                          9,
	"UPDATE_CONTRACT":                  10,
	"CHECK_CALLER_CERT_AUTH":           11,
	"GET_ENCLAVE_ENCRYPT_PUB_KEY":      12,
	"GET_ENCLAVE_VERIFICATION_PUB_KEY": 13,
	"GET_ENCLAVE_REPORT":               14,
	"GET_ENCLAVE_CHALLENGE":            15,
	"GET_ENCLAVE_SIGNATURE":            16,
	"SAVE_REMOTE_ATTESTATION":          17,
}

func (x PrivateComputeContractFunction) String() string {
	return proto.EnumName(PrivateComputeContractFunction_name, int32(x))
}

func (PrivateComputeContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{7}
}

//ContractStatus 合约状态
type ContractStatus int32

const (
	//未知
	ContractStatus_UNKNOWN ContractStatus = 0
	//普通正常状态
	ContractStatus_NORMAL ContractStatus = 1
	//冻结
	ContractStatus_FROZEN ContractStatus = 2
	//被撤销
	ContractStatus_REVOKED ContractStatus = 3
)

var ContractStatus_name = map[int32]string{
	0: "UNKNOWN",
	1: "NORMAL",
	2: "FROZEN",
	3: "REVOKED",
}

var ContractStatus_value = map[string]int32{
	"UNKNOWN": 0,
	"NORMAL":  1,
	"FROZEN":  2,
	"REVOKED": 3,
}

func (x ContractStatus) String() string {
	return proto.EnumName(ContractStatus_name, int32(x))
}

func (ContractStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{8}
}

type ContractType int32

const (
	//normal,support parallel
	ContractType_PARALLEL ContractType = 0
	//don't support parallel, for example: SQL contract
	ContractType_SERIAL ContractType = 1
	//like Fabric contract, run contract need add endorsement, for example: TEE contract
	ContractType_ENDORSE ContractType = 2
	//only pack 1 tx in block
	ContractType_SINGLE ContractType = 4
)

var ContractType_name = map[int32]string{
	0: "PARALLEL",
	1: "SERIAL",
	2: "ENDORSE",
	4: "SINGLE",
}

var ContractType_value = map[string]int32{
	"PARALLEL": 0,
	"SERIAL":   1,
	"ENDORSE":  2,
	"SINGLE":   4,
}

func (x ContractType) String() string {
	return proto.EnumName(ContractType_name, int32(x))
}

func (ContractType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{9}
}

type DPoSERC20ContractFunction int32

const (
	// get owner of DPoS
	DPoSERC20ContractFunction_GET_OWNER DPoSERC20ContractFunction = 0
	// get decimals of DPoS
	DPoSERC20ContractFunction_GET_DECIMALS DPoSERC20ContractFunction = 1
	// transfer token at DPoS
	DPoSERC20ContractFunction_TRANSFER DPoSERC20ContractFunction = 2
	// transfer token from user at DPoS
	DPoSERC20ContractFunction_TRANSFER_FROM DPoSERC20ContractFunction = 3
	// get balance of user at DPoS
	DPoSERC20ContractFunction_GET_BALANCEOF DPoSERC20ContractFunction = 4
	// approve token for user to other user at DPoS
	DPoSERC20ContractFunction_APPROVE DPoSERC20ContractFunction = 5
	// get allowance at DPoS
	DPoSERC20ContractFunction_GET_ALLOWANCE DPoSERC20ContractFunction = 6
	// burn token at DPoS
	DPoSERC20ContractFunction_BURN DPoSERC20ContractFunction = 7
	// mint token at DPoS
	DPoSERC20ContractFunction_MINT DPoSERC20ContractFunction = 8
	// transfer owner ship at DPoS
	DPoSERC20ContractFunction_TRANSFER_OWNERSHIP DPoSERC20ContractFunction = 9
)

var DPoSERC20ContractFunction_name = map[int32]string{
	0: "GET_OWNER",
	1: "GET_DECIMALS",
	2: "TRANSFER",
	3: "TRANSFER_FROM",
	4: "GET_BALANCEOF",
	5: "APPROVE",
	6: "GET_ALLOWANCE",
	7: "BURN",
	8: "MINT",
	9: "TRANSFER_OWNERSHIP",
}

var DPoSERC20ContractFunction_value = map[string]int32{
	"GET_OWNER":          0,
	"GET_DECIMALS":       1,
	"TRANSFER":           2,
	"TRANSFER_FROM":      3,
	"GET_BALANCEOF":      4,
	"APPROVE":            5,
	"GET_ALLOWANCE":      6,
	"BURN":               7,
	"MINT":               8,
	"TRANSFER_OWNERSHIP": 9,
}

func (x DPoSERC20ContractFunction) String() string {
	return proto.EnumName(DPoSERC20ContractFunction_name, int32(x))
}

func (DPoSERC20ContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{10}
}

type DPoSStakeContractFunction int32

const (
	// get all validator
	DPoSStakeContractFunction_GET_ALL_VALIDATOR DPoSStakeContractFunction = 0
	// get validator by address
	DPoSStakeContractFunction_GET_VALIDATOR_BY_ADDRESS DPoSStakeContractFunction = 1
	// delegate
	DPoSStakeContractFunction_DELEGATE DPoSStakeContractFunction = 2
	// get delegate by address
	DPoSStakeContractFunction_GET_DELEGATIONS_BY_ADDRESS DPoSStakeContractFunction = 3
	// get user delegation by validator
	DPoSStakeContractFunction_GET_USER_DELEGATION_BY_VALIDATOR DPoSStakeContractFunction = 4
	// undelegate
	DPoSStakeContractFunction_UNDELEGATE DPoSStakeContractFunction = 5
	// read epoch by id
	DPoSStakeContractFunction_READ_EPOCH_BY_ID DPoSStakeContractFunction = 6
	// read latest epoch
	DPoSStakeContractFunction_READ_LATEST_EPOCH DPoSStakeContractFunction = 7
	// set node id before join network
	DPoSStakeContractFunction_SET_NODE_ID DPoSStakeContractFunction = 8
	// get node id after join network
	DPoSStakeContractFunction_GET_NODE_ID DPoSStakeContractFunction = 9
	// update min self delegation
	DPoSStakeContractFunction_UPDATE_MIN_SELF_DELEGATION DPoSStakeContractFunction = 10
	// read min self delegation
	DPoSStakeContractFunction_READ_MIN_SELF_DELEGATION DPoSStakeContractFunction = 11
	// update epoch validator number
	DPoSStakeContractFunction_UPDATE_EPOCH_VALIDATOR_NUMBER DPoSStakeContractFunction = 12
	// read epoch validator number
	DPoSStakeContractFunction_READ_EPOCH_VALIDATOR_NUMBER DPoSStakeContractFunction = 13
	// update epoch block number
	DPoSStakeContractFunction_UPDATE_EPOCH_BLOCK_NUMBER DPoSStakeContractFunction = 14
	// read epoch block number
	DPoSStakeContractFunction_READ_EPOCH_BLOCK_NUMBER DPoSStakeContractFunction = 15
)

var DPoSStakeContractFunction_name = map[int32]string{
	0:  "GET_ALL_VALIDATOR",
	1:  "GET_VALIDATOR_BY_ADDRESS",
	2:  "DELEGATE",
	3:  "GET_DELEGATIONS_BY_ADDRESS",
	4:  "GET_USER_DELEGATION_BY_VALIDATOR",
	5:  "UNDELEGATE",
	6:  "READ_EPOCH_BY_ID",
	7:  "READ_LATEST_EPOCH",
	8:  "SET_NODE_ID",
	9:  "GET_NODE_ID",
	10: "UPDATE_MIN_SELF_DELEGATION",
	11: "READ_MIN_SELF_DELEGATION",
	12: "UPDATE_EPOCH_VALIDATOR_NUMBER",
	13: "READ_EPOCH_VALIDATOR_NUMBER",
	14: "UPDATE_EPOCH_BLOCK_NUMBER",
	15: "READ_EPOCH_BLOCK_NUMBER",
}

var DPoSStakeContractFunction_value = map[string]int32{
	"GET_ALL_VALIDATOR":                0,
	"GET_VALIDATOR_BY_ADDRESS":         1,
	"DELEGATE":                         2,
	"GET_DELEGATIONS_BY_ADDRESS":       3,
	"GET_USER_DELEGATION_BY_VALIDATOR": 4,
	"UNDELEGATE":                       5,
	"READ_EPOCH_BY_ID":                 6,
	"READ_LATEST_EPOCH":                7,
	"SET_NODE_ID":                      8,
	"GET_NODE_ID":                      9,
	"UPDATE_MIN_SELF_DELEGATION":       10,
	"READ_MIN_SELF_DELEGATION":         11,
	"UPDATE_EPOCH_VALIDATOR_NUMBER":    12,
	"READ_EPOCH_VALIDATOR_NUMBER":      13,
	"UPDATE_EPOCH_BLOCK_NUMBER":        14,
	"READ_EPOCH_BLOCK_NUMBER":          15,
}

func (x DPoSStakeContractFunction) String() string {
	return proto.EnumName(DPoSStakeContractFunction_name, int32(x))
}

func (DPoSStakeContractFunction) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{11}
}

type BondStatus int32

const (
	BondStatus_Bonded    BondStatus = 0
	BondStatus_Unbonding BondStatus = 1
	BondStatus_Unbonded  BondStatus = 2
)

var BondStatus_name = map[int32]string{
	0: "Bonded",
	1: "Unbonding",
	2: "Unbonded",
}

var BondStatus_value = map[string]int32{
	"Bonded":    0,
	"Unbonding": 1,
	"Unbonded":  2,
}

func (x BondStatus) String() string {
	return proto.EnumName(BondStatus_name, int32(x))
}

func (BondStatus) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{12}
}

// the unique identifier of a smart contract
type ContractId struct {
	// smart contract name, set by contract creator, can have multiple versions
	ContractName string `protobuf:"bytes,1,opt,name=contract_name,json=contractName,proto3" json:"contract_name,omitempty"`
	// smart contract version, set by contract creator, name + version should be unique
	ContractVersion string `protobuf:"bytes,2,opt,name=contract_version,json=contractVersion,proto3" json:"contract_version,omitempty"`
	// smart contract runtime type, set by contract creator
	RuntimeType RuntimeType `protobuf:"varint,3,opt,name=runtime_type,json=runtimeType,proto3,enum=common.RuntimeType" json:"runtime_type,omitempty"`
}

func (m *ContractId) Reset()         { *m = ContractId{} }
func (m *ContractId) String() string { return proto.CompactTextString(m) }
func (*ContractId) ProtoMessage()    {}
func (*ContractId) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{0}
}
func (m *ContractId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractId.Merge(m, src)
}
func (m *ContractId) XXX_Size() int {
	return m.Size()
}
func (m *ContractId) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractId.DiscardUnknown(m)
}

var xxx_messageInfo_ContractId proto.InternalMessageInfo

func (m *ContractId) GetContractName() string {
	if m != nil {
		return m.ContractName
	}
	return ""
}

func (m *ContractId) GetContractVersion() string {
	if m != nil {
		return m.ContractVersion
	}
	return ""
}

func (m *ContractId) GetRuntimeType() RuntimeType {
	if m != nil {
		return m.RuntimeType
	}
	return RuntimeType_INVALID
}

type ContractInfo struct {
	ContractTransaction []*ContractTransaction `protobuf:"bytes,1,rep,name=contract_transaction,json=contractTransaction,proto3" json:"contract_transaction,omitempty"`
}

func (m *ContractInfo) Reset()         { *m = ContractInfo{} }
func (m *ContractInfo) String() string { return proto.CompactTextString(m) }
func (*ContractInfo) ProtoMessage()    {}
func (*ContractInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{1}
}
func (m *ContractInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractInfo.Merge(m, src)
}
func (m *ContractInfo) XXX_Size() int {
	return m.Size()
}
func (m *ContractInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractInfo.DiscardUnknown(m)
}

var xxx_messageInfo_ContractInfo proto.InternalMessageInfo

func (m *ContractInfo) GetContractTransaction() []*ContractTransaction {
	if m != nil {
		return m.ContractTransaction
	}
	return nil
}

type ContractTransaction struct {
	ContractId *ContractId `protobuf:"bytes,1,opt,name=contract_id,json=contractId,proto3" json:"contract_id,omitempty"`
	TxId       string      `protobuf:"bytes,2,opt,name=tx_id,json=txId,proto3" json:"tx_id,omitempty"`
}

func (m *ContractTransaction) Reset()         { *m = ContractTransaction{} }
func (m *ContractTransaction) String() string { return proto.CompactTextString(m) }
func (*ContractTransaction) ProtoMessage()    {}
func (*ContractTransaction) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{2}
}
func (m *ContractTransaction) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractTransaction) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractTransaction.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractTransaction) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractTransaction.Merge(m, src)
}
func (m *ContractTransaction) XXX_Size() int {
	return m.Size()
}
func (m *ContractTransaction) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractTransaction.DiscardUnknown(m)
}

var xxx_messageInfo_ContractTransaction proto.InternalMessageInfo

func (m *ContractTransaction) GetContractId() *ContractId {
	if m != nil {
		return m.ContractId
	}
	return nil
}

func (m *ContractTransaction) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type Contract struct {
	// smart contract name, set by contract creator, can have multiple versions
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// smart contract version, set by contract creator, name + version should be unique
	Version string `protobuf:"bytes,2,opt,name=version,proto3" json:"version,omitempty"`
	// smart contract runtime type, set by contract creator
	RuntimeType RuntimeType `protobuf:"varint,3,opt,name=runtime_type,json=runtimeType,proto3,enum=common.RuntimeType" json:"runtime_type,omitempty"`
	//contract status
	Status ContractStatus `protobuf:"varint,4,opt,name=status,proto3,enum=common.ContractStatus" json:"status,omitempty"`
	// contract run parallel or need endorsement
	Type ContractType `protobuf:"varint,5,opt,name=type,proto3,enum=common.ContractType" json:"type,omitempty"`
	//if need endorsement,specify policy
	EndorsePolicy *accesscontrol.Policy `protobuf:"bytes,6,opt,name=endorse_policy,json=endorsePolicy,proto3" json:"endorse_policy,omitempty"`
	//contract upgrade policy
	UpdatePolicy *accesscontrol.Policy `protobuf:"bytes,7,opt,name=update_policy,json=updatePolicy,proto3" json:"update_policy,omitempty"`
	//contract initial block timestamp
	CreateTime int64 `protobuf:"varint,8,opt,name=create_time,json=createTime,proto3" json:"create_time,omitempty"`
	//contract creator identity
	Creator *accesscontrol.SerializedMember `protobuf:"bytes,9,opt,name=creator,proto3" json:"creator,omitempty"`
	//contract identity
	Address *accesscontrol.SerializedMember `protobuf:"bytes,10,opt,name=address,proto3" json:"address,omitempty"`
}

func (m *Contract) Reset()         { *m = Contract{} }
func (m *Contract) String() string { return proto.CompactTextString(m) }
func (*Contract) ProtoMessage()    {}
func (*Contract) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{3}
}
func (m *Contract) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Contract) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Contract.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Contract) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Contract.Merge(m, src)
}
func (m *Contract) XXX_Size() int {
	return m.Size()
}
func (m *Contract) XXX_DiscardUnknown() {
	xxx_messageInfo_Contract.DiscardUnknown(m)
}

var xxx_messageInfo_Contract proto.InternalMessageInfo

func (m *Contract) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *Contract) GetVersion() string {
	if m != nil {
		return m.Version
	}
	return ""
}

func (m *Contract) GetRuntimeType() RuntimeType {
	if m != nil {
		return m.RuntimeType
	}
	return RuntimeType_INVALID
}

func (m *Contract) GetStatus() ContractStatus {
	if m != nil {
		return m.Status
	}
	return ContractStatus_UNKNOWN
}

func (m *Contract) GetType() ContractType {
	if m != nil {
		return m.Type
	}
	return ContractType_PARALLEL
}

func (m *Contract) GetEndorsePolicy() *accesscontrol.Policy {
	if m != nil {
		return m.EndorsePolicy
	}
	return nil
}

func (m *Contract) GetUpdatePolicy() *accesscontrol.Policy {
	if m != nil {
		return m.UpdatePolicy
	}
	return nil
}

func (m *Contract) GetCreateTime() int64 {
	if m != nil {
		return m.CreateTime
	}
	return 0
}

func (m *Contract) GetCreator() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Creator
	}
	return nil
}

func (m *Contract) GetAddress() *accesscontrol.SerializedMember {
	if m != nil {
		return m.Address
	}
	return nil
}

type ContractList struct {
	Contracts []*Contract `protobuf:"bytes,1,rep,name=contracts,proto3" json:"contracts,omitempty"`
}

func (m *ContractList) Reset()         { *m = ContractList{} }
func (m *ContractList) String() string { return proto.CompactTextString(m) }
func (*ContractList) ProtoMessage()    {}
func (*ContractList) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{4}
}
func (m *ContractList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ContractList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ContractList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ContractList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContractList.Merge(m, src)
}
func (m *ContractList) XXX_Size() int {
	return m.Size()
}
func (m *ContractList) XXX_DiscardUnknown() {
	xxx_messageInfo_ContractList.DiscardUnknown(m)
}

var xxx_messageInfo_ContractList proto.InternalMessageInfo

func (m *ContractList) GetContracts() []*Contract {
	if m != nil {
		return m.Contracts
	}
	return nil
}

type Epoch struct {
	EpochID               uint64   `protobuf:"varint,1,opt,name=EpochID,proto3" json:"EpochID,omitempty"`
	ProposerVector        []string `protobuf:"bytes,2,rep,name=ProposerVector,proto3" json:"ProposerVector,omitempty"`
	NextEpochCreateHeight uint64   `protobuf:"varint,3,opt,name=NextEpochCreateHeight,proto3" json:"NextEpochCreateHeight,omitempty"`
}

func (m *Epoch) Reset()         { *m = Epoch{} }
func (m *Epoch) String() string { return proto.CompactTextString(m) }
func (*Epoch) ProtoMessage()    {}
func (*Epoch) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{5}
}
func (m *Epoch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Epoch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Epoch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Epoch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Epoch.Merge(m, src)
}
func (m *Epoch) XXX_Size() int {
	return m.Size()
}
func (m *Epoch) XXX_DiscardUnknown() {
	xxx_messageInfo_Epoch.DiscardUnknown(m)
}

var xxx_messageInfo_Epoch proto.InternalMessageInfo

func (m *Epoch) GetEpochID() uint64 {
	if m != nil {
		return m.EpochID
	}
	return 0
}

func (m *Epoch) GetProposerVector() []string {
	if m != nil {
		return m.ProposerVector
	}
	return nil
}

func (m *Epoch) GetNextEpochCreateHeight() uint64 {
	if m != nil {
		return m.NextEpochCreateHeight
	}
	return 0
}

type Validator struct {
	ValidatorAddress           string     `protobuf:"bytes,1,opt,name=ValidatorAddress,proto3" json:"ValidatorAddress,omitempty"`
	Jailed                     bool       `protobuf:"varint,2,opt,name=Jailed,proto3" json:"Jailed,omitempty"`
	Status                     BondStatus `protobuf:"varint,3,opt,name=Status,proto3,enum=common.BondStatus" json:"Status,omitempty"`
	Tokens                     string     `protobuf:"bytes,4,opt,name=Tokens,proto3" json:"Tokens,omitempty"`
	DelegatorShares            string     `protobuf:"bytes,5,opt,name=DelegatorShares,proto3" json:"DelegatorShares,omitempty"`
	UnbondingEpochID           uint64     `protobuf:"varint,6,opt,name=UnbondingEpochID,proto3" json:"UnbondingEpochID,omitempty"`
	UnbondingCompletionEpochID uint64     `protobuf:"varint,7,opt,name=UnbondingCompletionEpochID,proto3" json:"UnbondingCompletionEpochID,omitempty"`
	SelfDelegation             string     `protobuf:"bytes,8,opt,name=SelfDelegation,proto3" json:"SelfDelegation,omitempty"`
}

func (m *Validator) Reset()         { *m = Validator{} }
func (m *Validator) String() string { return proto.CompactTextString(m) }
func (*Validator) ProtoMessage()    {}
func (*Validator) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{6}
}
func (m *Validator) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Validator) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Validator.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Validator) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Validator.Merge(m, src)
}
func (m *Validator) XXX_Size() int {
	return m.Size()
}
func (m *Validator) XXX_DiscardUnknown() {
	xxx_messageInfo_Validator.DiscardUnknown(m)
}

var xxx_messageInfo_Validator proto.InternalMessageInfo

func (m *Validator) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *Validator) GetJailed() bool {
	if m != nil {
		return m.Jailed
	}
	return false
}

func (m *Validator) GetStatus() BondStatus {
	if m != nil {
		return m.Status
	}
	return BondStatus_Bonded
}

func (m *Validator) GetTokens() string {
	if m != nil {
		return m.Tokens
	}
	return ""
}

func (m *Validator) GetDelegatorShares() string {
	if m != nil {
		return m.DelegatorShares
	}
	return ""
}

func (m *Validator) GetUnbondingEpochID() uint64 {
	if m != nil {
		return m.UnbondingEpochID
	}
	return 0
}

func (m *Validator) GetUnbondingCompletionEpochID() uint64 {
	if m != nil {
		return m.UnbondingCompletionEpochID
	}
	return 0
}

func (m *Validator) GetSelfDelegation() string {
	if m != nil {
		return m.SelfDelegation
	}
	return ""
}

type Delegation struct {
	DelegatorAddress string `protobuf:"bytes,1,opt,name=DelegatorAddress,proto3" json:"DelegatorAddress,omitempty"`
	ValidatorAddress string `protobuf:"bytes,2,opt,name=ValidatorAddress,proto3" json:"ValidatorAddress,omitempty"`
	Shares           string `protobuf:"bytes,3,opt,name=Shares,proto3" json:"Shares,omitempty"`
}

func (m *Delegation) Reset()         { *m = Delegation{} }
func (m *Delegation) String() string { return proto.CompactTextString(m) }
func (*Delegation) ProtoMessage()    {}
func (*Delegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{7}
}
func (m *Delegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Delegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Delegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Delegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Delegation.Merge(m, src)
}
func (m *Delegation) XXX_Size() int {
	return m.Size()
}
func (m *Delegation) XXX_DiscardUnknown() {
	xxx_messageInfo_Delegation.DiscardUnknown(m)
}

var xxx_messageInfo_Delegation proto.InternalMessageInfo

func (m *Delegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *Delegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *Delegation) GetShares() string {
	if m != nil {
		return m.Shares
	}
	return ""
}

type UnbondingDelegation struct {
	EpochID          string                      `protobuf:"bytes,1,opt,name=EpochID,proto3" json:"EpochID,omitempty"`
	DelegatorAddress string                      `protobuf:"bytes,2,opt,name=DelegatorAddress,proto3" json:"DelegatorAddress,omitempty"`
	ValidatorAddress string                      `protobuf:"bytes,3,opt,name=ValidatorAddress,proto3" json:"ValidatorAddress,omitempty"`
	Entries          []*UnbondingDelegationEntry `protobuf:"bytes,4,rep,name=Entries,proto3" json:"Entries,omitempty"`
}

func (m *UnbondingDelegation) Reset()         { *m = UnbondingDelegation{} }
func (m *UnbondingDelegation) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegation) ProtoMessage()    {}
func (*UnbondingDelegation) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{8}
}
func (m *UnbondingDelegation) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegation.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegation.Merge(m, src)
}
func (m *UnbondingDelegation) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegation) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegation.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegation proto.InternalMessageInfo

func (m *UnbondingDelegation) GetEpochID() string {
	if m != nil {
		return m.EpochID
	}
	return ""
}

func (m *UnbondingDelegation) GetDelegatorAddress() string {
	if m != nil {
		return m.DelegatorAddress
	}
	return ""
}

func (m *UnbondingDelegation) GetValidatorAddress() string {
	if m != nil {
		return m.ValidatorAddress
	}
	return ""
}

func (m *UnbondingDelegation) GetEntries() []*UnbondingDelegationEntry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type UnbondingDelegationEntry struct {
	CreationEpochID   uint64 `protobuf:"varint,1,opt,name=CreationEpochID,proto3" json:"CreationEpochID,omitempty"`
	CompletionEpochID uint64 `protobuf:"varint,2,opt,name=CompletionEpochID,proto3" json:"CompletionEpochID,omitempty"`
	Amount            string `protobuf:"bytes,3,opt,name=Amount,proto3" json:"Amount,omitempty"`
}

func (m *UnbondingDelegationEntry) Reset()         { *m = UnbondingDelegationEntry{} }
func (m *UnbondingDelegationEntry) String() string { return proto.CompactTextString(m) }
func (*UnbondingDelegationEntry) ProtoMessage()    {}
func (*UnbondingDelegationEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{9}
}
func (m *UnbondingDelegationEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UnbondingDelegationEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UnbondingDelegationEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UnbondingDelegationEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UnbondingDelegationEntry.Merge(m, src)
}
func (m *UnbondingDelegationEntry) XXX_Size() int {
	return m.Size()
}
func (m *UnbondingDelegationEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_UnbondingDelegationEntry.DiscardUnknown(m)
}

var xxx_messageInfo_UnbondingDelegationEntry proto.InternalMessageInfo

func (m *UnbondingDelegationEntry) GetCreationEpochID() uint64 {
	if m != nil {
		return m.CreationEpochID
	}
	return 0
}

func (m *UnbondingDelegationEntry) GetCompletionEpochID() uint64 {
	if m != nil {
		return m.CompletionEpochID
	}
	return 0
}

func (m *UnbondingDelegationEntry) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type ValidatorVector struct {
	Vector []string `protobuf:"bytes,1,rep,name=Vector,proto3" json:"Vector,omitempty"`
}

func (m *ValidatorVector) Reset()         { *m = ValidatorVector{} }
func (m *ValidatorVector) String() string { return proto.CompactTextString(m) }
func (*ValidatorVector) ProtoMessage()    {}
func (*ValidatorVector) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{10}
}
func (m *ValidatorVector) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ValidatorVector) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ValidatorVector.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ValidatorVector) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValidatorVector.Merge(m, src)
}
func (m *ValidatorVector) XXX_Size() int {
	return m.Size()
}
func (m *ValidatorVector) XXX_DiscardUnknown() {
	xxx_messageInfo_ValidatorVector.DiscardUnknown(m)
}

var xxx_messageInfo_ValidatorVector proto.InternalMessageInfo

func (m *ValidatorVector) GetVector() []string {
	if m != nil {
		return m.Vector
	}
	return nil
}

type DelegationInfo struct {
	Infos []*Delegation `protobuf:"bytes,1,rep,name=Infos,proto3" json:"Infos,omitempty"`
}

func (m *DelegationInfo) Reset()         { *m = DelegationInfo{} }
func (m *DelegationInfo) String() string { return proto.CompactTextString(m) }
func (*DelegationInfo) ProtoMessage()    {}
func (*DelegationInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_a1095c55e7168440, []int{11}
}
func (m *DelegationInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DelegationInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DelegationInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DelegationInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DelegationInfo.Merge(m, src)
}
func (m *DelegationInfo) XXX_Size() int {
	return m.Size()
}
func (m *DelegationInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_DelegationInfo.DiscardUnknown(m)
}

var xxx_messageInfo_DelegationInfo proto.InternalMessageInfo

func (m *DelegationInfo) GetInfos() []*Delegation {
	if m != nil {
		return m.Infos
	}
	return nil
}

func init() {
	proto.RegisterEnum("common.ContractName", ContractName_name, ContractName_value)
	proto.RegisterEnum("common.QueryFunction", QueryFunction_name, QueryFunction_value)
	proto.RegisterEnum("common.RuntimeType", RuntimeType_name, RuntimeType_value)
	proto.RegisterEnum("common.ConfigFunction", ConfigFunction_name, ConfigFunction_value)
	proto.RegisterEnum("common.CertManageFunction", CertManageFunction_name, CertManageFunction_value)
	proto.RegisterEnum("common.MultiSignFunction", MultiSignFunction_name, MultiSignFunction_value)
	proto.RegisterEnum("common.ManageUserContractFunction", ManageUserContractFunction_name, ManageUserContractFunction_value)
	proto.RegisterEnum("common.PrivateComputeContractFunction", PrivateComputeContractFunction_name, PrivateComputeContractFunction_value)
	proto.RegisterEnum("common.ContractStatus", ContractStatus_name, ContractStatus_value)
	proto.RegisterEnum("common.ContractType", ContractType_name, ContractType_value)
	proto.RegisterEnum("common.DPoSERC20ContractFunction", DPoSERC20ContractFunction_name, DPoSERC20ContractFunction_value)
	proto.RegisterEnum("common.DPoSStakeContractFunction", DPoSStakeContractFunction_name, DPoSStakeContractFunction_value)
	proto.RegisterEnum("common.BondStatus", BondStatus_name, BondStatus_value)
	proto.RegisterType((*ContractId)(nil), "common.ContractId")
	proto.RegisterType((*ContractInfo)(nil), "common.ContractInfo")
	proto.RegisterType((*ContractTransaction)(nil), "common.ContractTransaction")
	proto.RegisterType((*Contract)(nil), "common.Contract")
	proto.RegisterType((*ContractList)(nil), "common.ContractList")
	proto.RegisterType((*Epoch)(nil), "common.Epoch")
	proto.RegisterType((*Validator)(nil), "common.Validator")
	proto.RegisterType((*Delegation)(nil), "common.Delegation")
	proto.RegisterType((*UnbondingDelegation)(nil), "common.UnbondingDelegation")
	proto.RegisterType((*UnbondingDelegationEntry)(nil), "common.UnbondingDelegationEntry")
	proto.RegisterType((*ValidatorVector)(nil), "common.ValidatorVector")
	proto.RegisterType((*DelegationInfo)(nil), "common.DelegationInfo")
}

func init() { proto.RegisterFile("common/contract.proto", fileDescriptor_a1095c55e7168440) }

var fileDescriptor_a1095c55e7168440 = []byte{
	// 2206 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x9c, 0x58, 0x4b, 0x6f, 0x23, 0x59,
	0xf5, 0x8f, 0xdf, 0xf6, 0xb1, 0x9d, 0xdc, 0xdc, 0x74, 0x32, 0x9e, 0xf4, 0x4c, 0x3a, 0xe3, 0xf9,
	0xff, 0x51, 0xc6, 0x82, 0x04, 0x7a, 0x00, 0x89, 0x16, 0x1a, 0xa9, 0x52, 0x75, 0x6d, 0xd7, 0xa4,
	0x5c, 0xe5, 0xbe, 0x55, 0x76, 0x3a, 0xbd, 0xa0, 0xe4, 0xd8, 0xd5, 0x69, 0xab, 0x63, 0x57, 0x54,
	0x76, 0x46, 0xdd, 0x08, 0xc4, 0x8e, 0x05, 0x2b, 0x16, 0xf3, 0x31, 0xd8, 0xb1, 0x65, 0x83, 0xd8,
	0xb0, 0x1c, 0x76, 0x48, 0x6c, 0x50, 0xb7, 0xf8, 0x1e, 0xe8, 0xdc, 0x5b, 0xaf, 0xd8, 0xe9, 0x16,
	0xb0, 0x8a, 0xcf, 0xef, 0x3c, 0xee, 0xef, 0x9e, 0x7b, 0x1e, 0x76, 0x60, 0x77, 0xec, 0xcf, 0x66,
	0xfe, 0xfc, 0x64, 0xec, 0xcf, 0x97, 0xc1, 0x68, 0xbc, 0x3c, 0xbe, 0x09, 0xfc, 0xa5, 0x4f, 0x8b,
	0x12, 0xde, 0xdf, 0x1f, 0x8d, 0xc7, 0xde, 0x62, 0x21, 0xb4, 0xfe, 0xf5, 0xc9, 0xcc, 0x9b, 0x5d,
	0x7a, 0x81, 0xb4, 0x59, 0xd5, 0xdd, 0xf8, 0xd7, 0xd3, 0xf1, 0x1b, 0xa9, 0x6b, 0x7e, 0x9b, 0x01,
	0x50, 0xc3, 0x90, 0xfa, 0x84, 0x7e, 0x0e, 0xf5, 0xe8, 0x00, 0x77, 0x3e, 0x9a, 0x79, 0x8d, 0xcc,
	0x61, 0xe6, 0xa8, 0xc2, 0x6b, 0x11, 0x68, 0x8e, 0x66, 0x1e, 0xfd, 0x02, 0x48, 0x6c, 0xf4, 0x8d,
	0x17, 0x2c, 0xa6, 0xfe, 0xbc, 0x91, 0x15, 0x76, 0x5b, 0x11, 0x3e, 0x94, 0x30, 0xfd, 0x29, 0xd4,
	0x82, 0xdb, 0xf9, 0x72, 0x3a, 0xf3, 0xdc, 0xe5, 0x9b, 0x1b, 0xaf, 0x91, 0x3b, 0xcc, 0x1c, 0x6d,
	0x3e, 0xde, 0x39, 0x96, 0xac, 0x8f, 0xb9, 0xd4, 0x39, 0x6f, 0x6e, 0x3c, 0x5e, 0x0d, 0x12, 0xa1,
	0xf9, 0x0b, 0xa8, 0xc5, 0xac, 0xe6, 0x2f, 0x7c, 0x6a, 0xc2, 0x83, 0xf8, 0xc8, 0x65, 0x30, 0x9a,
	0x2f, 0x46, 0xe3, 0x25, 0x1e, 0x9b, 0x39, 0xcc, 0x1d, 0x55, 0x1f, 0x3f, 0x8c, 0xe2, 0x45, 0x3e,
	0x4e, 0x62, 0xc2, 0x77, 0xc6, 0xeb, 0x60, 0xd3, 0x85, 0x9d, 0x7b, 0x6c, 0xe9, 0x97, 0x50, 0x8d,
	0x8f, 0x99, 0x4e, 0xc4, 0xe5, 0xab, 0x8f, 0xe9, 0x6a, 0x74, 0x7d, 0xc2, 0x61, 0x9c, 0xe4, 0x6c,
	0x07, 0x0a, 0xcb, 0xd7, 0x68, 0x2e, 0x73, 0x90, 0x5f, 0xbe, 0xd6, 0x27, 0xcd, 0x7f, 0xe4, 0xa0,
	0x1c, 0xd9, 0x53, 0x0a, 0xf9, 0x54, 0x32, 0xc5, 0x67, 0xda, 0x80, 0xd2, 0xdd, 0xdc, 0x45, 0xe2,
	0xff, 0x9a, 0x33, 0x7a, 0x0c, 0xc5, 0xc5, 0x72, 0xb4, 0xbc, 0x5d, 0x34, 0xf2, 0xc2, 0x63, 0x6f,
	0x95, 0xb7, 0x2d, 0xb4, 0x3c, 0xb4, 0xa2, 0x47, 0x90, 0x17, 0xf1, 0x0b, 0xc2, 0xfa, 0xc1, 0x5a,
	0x0e, 0xf1, 0x00, 0x61, 0x41, 0x7f, 0x0e, 0x9b, 0xde, 0x7c, 0xe2, 0x07, 0x0b, 0xcf, 0x95, 0xc5,
	0xd3, 0x28, 0x8a, 0xcc, 0xec, 0x1e, 0xdf, 0xa9, 0xac, 0xe3, 0xbe, 0x50, 0xf2, 0x7a, 0x68, 0x2c,
	0x45, 0xfa, 0x04, 0xea, 0xb7, 0x37, 0x93, 0xd1, 0x32, 0x76, 0x2e, 0x7d, 0xc8, 0xb9, 0x26, 0x6d,
	0x43, 0xdf, 0x47, 0x50, 0x1d, 0x07, 0x1e, 0xfa, 0xe2, 0x35, 0x1b, 0xe5, 0xc3, 0xcc, 0x51, 0x8e,
	0x83, 0x84, 0x9c, 0xe9, 0xcc, 0xa3, 0x3f, 0x83, 0x92, 0x90, 0xfc, 0xa0, 0x51, 0x11, 0x61, 0x1f,
	0xad, 0x84, 0xb5, 0xbd, 0x60, 0x3a, 0xba, 0x9e, 0xfe, 0xd2, 0x9b, 0xf4, 0x44, 0x4f, 0xf0, 0xc8,
	0x1e, 0x5d, 0x47, 0x93, 0x49, 0xe0, 0x2d, 0x16, 0x0d, 0xf8, 0x0f, 0x5d, 0x43, 0xfb, 0xe6, 0x57,
	0x49, 0x79, 0x1a, 0xd3, 0xc5, 0x92, 0x1e, 0x43, 0x25, 0x2a, 0x88, 0x45, 0x58, 0x93, 0x64, 0x35,
	0x9f, 0x3c, 0x31, 0x69, 0xfe, 0x06, 0x0a, 0xec, 0xc6, 0x1f, 0xbf, 0xc4, 0x2a, 0x10, 0x1f, 0x74,
	0x4d, 0x14, 0x47, 0x9e, 0x47, 0x22, 0xfd, 0x1e, 0x6c, 0xf6, 0x03, 0xff, 0xc6, 0x5f, 0x78, 0xc1,
	0xd0, 0x1b, 0xe3, 0xfd, 0xb2, 0x87, 0xb9, 0xa3, 0x0a, 0x5f, 0x41, 0xe9, 0x8f, 0x61, 0xd7, 0xf4,
	0x5e, 0x2f, 0x85, 0x9b, 0x2a, 0xf2, 0xd2, 0xf5, 0xa6, 0x57, 0x2f, 0x97, 0xa2, 0x6c, 0xf2, 0xfc,
	0x7e, 0x65, 0xf3, 0x6f, 0x59, 0xa8, 0x0c, 0x47, 0xd7, 0xd3, 0x89, 0xc8, 0x44, 0x0b, 0x48, 0x2c,
	0x28, 0x61, 0x4a, 0x64, 0xad, 0xae, 0xe1, 0x74, 0x0f, 0x8a, 0x5f, 0x8f, 0xa6, 0xd7, 0x9e, 0x2c,
	0xf7, 0x32, 0x0f, 0x25, 0xda, 0x82, 0xa2, 0xac, 0xaf, 0xb0, 0x5e, 0xe3, 0xae, 0x39, 0xf5, 0xe7,
	0x93, 0xa8, 0xf2, 0xe4, 0x5f, 0x8c, 0xe1, 0xf8, 0xaf, 0xbc, 0xb9, 0xac, 0xd4, 0x0a, 0x0f, 0x25,
	0x7a, 0x04, 0x5b, 0x9a, 0x77, 0xed, 0x5d, 0xe1, 0x79, 0xf6, 0xcb, 0x51, 0xe0, 0x2d, 0x44, 0x71,
	0x56, 0xf8, 0x2a, 0x8c, 0x8c, 0x07, 0xf3, 0x4b, 0x7f, 0x3e, 0x99, 0xce, 0xaf, 0xa2, 0x04, 0x16,
	0xc5, 0x85, 0xd7, 0x70, 0xfa, 0x15, 0xec, 0xc7, 0x98, 0xea, 0xcf, 0x6e, 0xae, 0x3d, 0xec, 0xf5,
	0xc8, 0xab, 0x24, 0xbc, 0x3e, 0x60, 0x81, 0x2f, 0x61, 0x7b, 0xd7, 0x2f, 0x42, 0x0a, 0xd8, 0xb0,
	0x65, 0x41, 0x6a, 0x05, 0x6d, 0xfe, 0x0a, 0x20, 0x91, 0x90, 0x61, 0x4c, 0x7a, 0x25, 0xa7, 0xab,
	0xf8, 0xbd, 0xf9, 0xcf, 0xbe, 0x3f, 0xff, 0x61, 0x6a, 0x72, 0x32, 0x77, 0x52, 0x6a, 0xfe, 0x25,
	0x03, 0x3b, 0xf1, 0x25, 0x52, 0x3c, 0x56, 0x2a, 0xac, 0x92, 0x54, 0xd8, 0x7d, 0x0c, 0xb3, 0xff,
	0x05, 0xc3, 0xdc, 0x7b, 0x18, 0x3e, 0x81, 0x12, 0x9b, 0x2f, 0x83, 0xa9, 0x87, 0xcf, 0x8b, 0xad,
	0x70, 0x18, 0x95, 0xc2, 0x3d, 0xfc, 0xd0, 0xf2, 0x0d, 0x8f, 0x1c, 0x9a, 0xbf, 0xcb, 0x40, 0xe3,
	0x7d, 0x56, 0x58, 0x1e, 0xa2, 0x88, 0x53, 0xaf, 0x27, 0x9b, 0x66, 0x15, 0xa6, 0xdf, 0x87, 0xed,
	0xf5, 0x97, 0xce, 0x0a, 0xdb, 0x75, 0x05, 0xa6, 0x54, 0x99, 0xf9, 0xb7, 0xf3, 0x65, 0x94, 0x52,
	0x29, 0x35, 0xbf, 0x80, 0xad, 0xf8, 0x72, 0x61, 0xb7, 0xed, 0x41, 0x31, 0xec, 0xc6, 0x8c, 0xe8,
	0xc6, 0x50, 0x6a, 0x3e, 0x81, 0xcd, 0x84, 0xad, 0xd8, 0x58, 0x47, 0x50, 0xc0, 0xbf, 0xd1, 0x38,
	0x88, 0xdb, 0x21, 0x31, 0xe3, 0xd2, 0xa0, 0xf5, 0x87, 0x6c, 0x32, 0x4d, 0xc4, 0x7e, 0x3d, 0x84,
	0x4f, 0xec, 0x0b, 0xdb, 0x61, 0x3d, 0x57, 0xb5, 0x4c, 0x87, 0x2b, 0xaa, 0xe3, 0xaa, 0x5d, 0x45,
	0x37, 0x51, 0x6c, 0xeb, 0x1d, 0xb2, 0x41, 0x3f, 0x86, 0xdd, 0x55, 0x8b, 0xa7, 0x03, 0xc6, 0x2f,
	0x48, 0x86, 0x3e, 0x82, 0x87, 0x6b, 0xce, 0x8c, 0x3b, 0x6e, 0x4f, 0x31, 0x95, 0x0e, 0x23, 0x59,
	0x7a, 0x00, 0xfb, 0xab, 0x06, 0x1d, 0x6b, 0xc8, 0xb8, 0xa9, 0x98, 0x2a, 0x23, 0xb9, 0xfb, 0xf4,
	0xbd, 0x81, 0xe1, 0xe8, 0xae, 0xad, 0x77, 0x4c, 0x92, 0xbf, 0xef, 0x6c, 0xdb, 0x51, 0x1c, 0x46,
	0x0a, 0xf4, 0x73, 0x78, 0xb4, 0xaa, 0xea, 0x73, 0x7d, 0xa8, 0x38, 0xcc, 0x55, 0xad, 0x5e, 0x7f,
	0xe0, 0x30, 0x52, 0xbc, 0x2f, 0xbe, 0xd6, 0xb7, 0x6c, 0x97, 0x71, 0xf5, 0xf1, 0x0f, 0x49, 0xe9,
	0xbd, 0x7a, 0xdb, 0x51, 0xce, 0x18, 0x29, 0xb7, 0xbe, 0xcd, 0x43, 0xfd, 0xe9, 0xad, 0x17, 0xbc,
	0x69, 0xdf, 0xce, 0xe5, 0xd6, 0xde, 0x03, 0xda, 0x61, 0x8e, 0x7b, 0x6a, 0x58, 0xea, 0x99, 0x7b,
	0x7a, 0xe1, 0x3a, 0xcf, 0x5c, 0x5d, 0x23, 0x1b, 0x74, 0x17, 0xb6, 0x11, 0x8f, 0xc3, 0xe8, 0x66,
	0xdb, 0x22, 0x19, 0xba, 0x03, 0x5b, 0x08, 0x3b, 0xcf, 0x12, 0xdb, 0x2c, 0xfd, 0x08, 0x76, 0xee,
	0xc4, 0xe8, 0x32, 0xbd, 0xd3, 0x75, 0x48, 0x8e, 0x52, 0xd8, 0x14, 0x41, 0xc4, 0x03, 0x88, 0x08,
	0x22, 0x05, 0x88, 0x19, 0x8a, 0xed, 0x84, 0x6f, 0x22, 0x1d, 0x49, 0x21, 0x3a, 0x33, 0x89, 0xa3,
	0xd8, 0x5d, 0x52, 0x8c, 0xc2, 0x9b, 0x96, 0xc6, 0xc2, 0x50, 0x86, 0x6e, 0x3b, 0xa4, 0x44, 0x1f,
	0xc2, 0x47, 0xa8, 0x48, 0x5e, 0x20, 0xa6, 0x4b, 0xca, 0xf4, 0xff, 0xe1, 0xb3, 0x24, 0xd8, 0xb9,
	0xee, 0x74, 0x5d, 0xe7, 0x19, 0x3f, 0xb7, 0x99, 0x63, 0xa7, 0x28, 0x56, 0x30, 0xed, 0x1f, 0x32,
	0x43, 0x06, 0x10, 0xdd, 0x43, 0x70, 0x96, 0x64, 0xab, 0xf4, 0x13, 0x68, 0x20, 0xd6, 0x1e, 0x18,
	0xc6, 0xda, 0xcd, 0x6b, 0xf4, 0x53, 0xf8, 0x38, 0x09, 0x2b, 0xd1, 0x24, 0x63, 0xf5, 0xc8, 0x79,
	0x55, 0x2d, 0x8e, 0xdb, 0xc4, 0x57, 0x4c, 0x6b, 0x15, 0x8d, 0xf1, 0x54, 0xf0, 0xad, 0x28, 0xb8,
	0xc2, 0xd5, 0xae, 0x3e, 0x64, 0xda, 0x9d, 0x30, 0x84, 0x44, 0x19, 0x8e, 0x9f, 0xee, 0xf4, 0xc2,
	0x61, 0xaa, 0xa5, 0x31, 0xb2, 0x1d, 0x65, 0x58, 0x31, 0x8c, 0x58, 0x6d, 0x13, 0xda, 0xf2, 0xa1,
	0x9a, 0xfa, 0x66, 0x44, 0xab, 0x50, 0xd2, 0xcd, 0xa1, 0x62, 0x88, 0x42, 0x00, 0x28, 0x9a, 0x8a,
	0xa3, 0x0f, 0x19, 0xc9, 0xe0, 0xe7, 0x73, 0xc5, 0xee, 0x31, 0x4e, 0xb2, 0xb4, 0x0c, 0xf9, 0xf3,
	0x67, 0xc3, 0x1e, 0xc9, 0xe1, 0xa7, 0x8e, 0x62, 0xf7, 0x48, 0x9e, 0x96, 0x20, 0xc7, 0x86, 0x3d,
	0x52, 0xa0, 0x75, 0xa8, 0x68, 0x96, 0x7a, 0xc6, 0xb8, 0xdb, 0xb1, 0x48, 0x91, 0x6e, 0x41, 0x35,
	0x14, 0xbf, 0x56, 0x86, 0x0a, 0x29, 0xb5, 0xfe, 0x95, 0x83, 0x4d, 0xd5, 0x9f, 0xbf, 0x98, 0x5e,
	0xc5, 0x85, 0xf8, 0x00, 0x48, 0x52, 0x2b, 0x71, 0xb3, 0x86, 0x6f, 0x9f, 0x46, 0x5d, 0xc5, 0x21,
	0x19, 0x0c, 0xa9, 0x5a, 0x9c, 0xb9, 0x83, 0xbe, 0x86, 0xfd, 0x93, 0xa5, 0x04, 0x6a, 0x32, 0x0f,
	0x21, 0x22, 0xaa, 0xcf, 0xe1, 0x03, 0xdb, 0x71, 0xb9, 0x65, 0x39, 0xae, 0xa2, 0x69, 0x24, 0x8f,
	0x09, 0x48, 0x61, 0xa1, 0x69, 0x61, 0x05, 0xd6, 0x98, 0xc1, 0x44, 0xbb, 0x6d, 0x43, 0x5d, 0x54,
	0x9d, 0xa2, 0x69, 0x5c, 0x04, 0x28, 0x21, 0xcd, 0x04, 0x0a, 0xfd, 0xcb, 0x77, 0xd1, 0xd0, 0xbd,
	0x82, 0x94, 0x04, 0x6a, 0xf1, 0x8e, 0xf0, 0x06, 0x6c, 0x9f, 0x18, 0x09, 0x9d, 0xab, 0x77, 0xc0,
	0xd0, 0xb7, 0x86, 0x8c, 0x54, 0xcb, 0xb4, 0x99, 0x69, 0x0f, 0x6c, 0x97, 0x3d, 0x93, 0xfc, 0xeb,
	0xb4, 0x01, 0x0f, 0xee, 0xc2, 0x61, 0x94, 0xcd, 0x75, 0x4d, 0x18, 0x6a, 0x0b, 0xf3, 0xd0, 0x67,
	0xbc, 0xa7, 0xdb, 0xb6, 0x6e, 0x99, 0x22, 0x0e, 0xc1, 0xf0, 0x29, 0x2c, 0x0c, 0xb2, 0xbd, 0x02,
	0x87, 0x11, 0x28, 0x26, 0x5b, 0x30, 0xd4, 0x35, 0xe1, 0xbe, 0x83, 0x21, 0x23, 0x20, 0xf4, 0x7d,
	0x90, 0xc6, 0x42, 0xc7, 0xdd, 0xd6, 0xaf, 0x81, 0xaa, 0x5e, 0xb0, 0xec, 0x8d, 0xe6, 0xa3, 0x2b,
	0x2f, 0x7e, 0xea, 0x1a, 0x94, 0xc5, 0x58, 0xc5, 0x58, 0x1b, 0x98, 0x25, 0x94, 0xec, 0xc8, 0x4b,
	0xbe, 0xad, 0x40, 0xe4, 0x5c, 0xce, 0x26, 0x26, 0x6d, 0xce, 0xd8, 0xf3, 0xf0, 0x6d, 0x25, 0x32,
	0x30, 0x43, 0x2c, 0x9f, 0x58, 0x71, 0x36, 0xb4, 0xce, 0x18, 0x29, 0xb4, 0x7e, 0x04, 0xdb, 0xbd,
	0xdb, 0xeb, 0xe5, 0xd4, 0x9e, 0x5e, 0xcd, 0xe3, 0xd3, 0x4b, 0x90, 0xe3, 0xec, 0x29, 0xd9, 0xc0,
	0xba, 0x1d, 0x5a, 0xe2, 0xc0, 0x0a, 0x14, 0xc2, 0xa3, 0x5a, 0xbf, 0xcd, 0xc0, 0xbe, 0xa4, 0x3b,
	0x58, 0x78, 0x41, 0xb4, 0x5a, 0x62, 0xe7, 0x6d, 0xa8, 0xeb, 0xa6, 0x9e, 0x34, 0x17, 0xd9, 0xc0,
	0xb7, 0x1f, 0xf4, 0x3b, 0x5c, 0xd1, 0x52, 0xe3, 0x47, 0x0c, 0x4a, 0x49, 0x2c, 0x01, 0xb3, 0x98,
	0xde, 0x88, 0x6f, 0x02, 0xe7, 0xd0, 0x56, 0x52, 0x4e, 0xc0, 0x7c, 0xeb, 0x8f, 0x39, 0x38, 0xe8,
	0x07, 0xd3, 0x6f, 0x46, 0x4b, 0x0f, 0xb7, 0xee, 0x2d, 0xfe, 0x59, 0x21, 0x43, 0xa0, 0x96, 0x6e,
	0x74, 0xb2, 0x81, 0x99, 0x45, 0x44, 0x53, 0x1c, 0x85, 0x64, 0x50, 0x6f, 0x2b, 0x43, 0xe6, 0xaa,
	0x8a, 0x58, 0x63, 0x24, 0x8b, 0x7a, 0x81, 0x68, 0x3a, 0x27, 0x39, 0xec, 0x52, 0x29, 0xa1, 0x79,
	0x1e, 0xef, 0x26, 0xcd, 0xa3, 0x78, 0x05, 0x6c, 0x3f, 0x01, 0x31, 0x53, 0x35, 0xf0, 0x2f, 0x67,
	0x7d, 0x8b, 0x3b, 0xa4, 0x18, 0x0d, 0x92, 0x08, 0xef, 0x73, 0xcb, 0x6a, 0x93, 0x12, 0xbe, 0x9c,
	0x60, 0x14, 0x1e, 0x58, 0xc6, 0x51, 0x22, 0x08, 0xe9, 0x9c, 0x54, 0xf0, 0x9e, 0xb2, 0x5a, 0x92,
	0x23, 0x80, 0xee, 0xc3, 0x9e, 0xda, 0x65, 0xea, 0x99, 0xab, 0x2a, 0x86, 0xc1, 0xb8, 0x5c, 0xb8,
	0xca, 0xc0, 0xe9, 0x92, 0x2a, 0xee, 0xe3, 0xf4, 0x29, 0xcc, 0x54, 0xf9, 0x45, 0xdf, 0x71, 0xfb,
	0x83, 0x53, 0xf7, 0x8c, 0x5d, 0x90, 0x1a, 0xfd, 0x3f, 0x38, 0x4c, 0x1b, 0x0c, 0x19, 0xd7, 0xdb,
	0xba, 0xaa, 0x38, 0x58, 0xbd, 0x91, 0x55, 0x3d, 0xda, 0x71, 0x2b, 0x97, 0xd8, 0x8c, 0x06, 0x65,
	0x84, 0xab, 0x5d, 0x64, 0x60, 0x76, 0xb0, 0x67, 0x56, 0x54, 0xb8, 0xbe, 0x15, 0x67, 0xc0, 0x19,
	0x21, 0xb8, 0x75, 0x6c, 0x19, 0xa6, 0x67, 0x39, 0xcc, 0x55, 0x1c, 0x87, 0xe1, 0x0e, 0xd7, 0x2d,
	0x93, 0x6c, 0xb7, 0x4e, 0xc5, 0x5c, 0x4b, 0xfd, 0x62, 0xc4, 0x0c, 0x0c, 0xcc, 0x33, 0xd3, 0x3a,
	0x37, 0xc3, 0x61, 0x6a, 0xf1, 0x9e, 0x62, 0xc8, 0x61, 0xda, 0xe6, 0xd6, 0x73, 0x66, 0x92, 0x2c,
	0x1a, 0xc9, 0x0a, 0xd0, 0x48, 0xae, 0xa5, 0x24, 0x5f, 0x69, 0xc4, 0x38, 0xae, 0x41, 0xb9, 0xaf,
	0x70, 0xe4, 0x66, 0xc8, 0x10, 0x36, 0xe3, 0xba, 0x08, 0x51, 0x85, 0x12, 0x33, 0x35, 0x8b, 0xdb,
	0x38, 0x00, 0x51, 0xa1, 0x9b, 0x1d, 0x83, 0x91, 0x7c, 0xeb, 0x4f, 0x19, 0xf8, 0x58, 0xeb, 0xfb,
	0xb6, 0xf8, 0x5e, 0xb0, 0x56, 0x37, 0x75, 0xa8, 0xe0, 0xe5, 0xac, 0x73, 0x93, 0x71, 0xd9, 0x80,
	0xe2, 0x8d, 0x98, 0xaa, 0xf7, 0x14, 0xc3, 0x26, 0x19, 0x3c, 0xd1, 0xe1, 0x8a, 0x69, 0xb7, 0xc5,
	0xa4, 0xdf, 0x86, 0x7a, 0x24, 0xb9, 0x6d, 0x6e, 0xe1, 0xc8, 0xdf, 0x86, 0xba, 0xd8, 0x50, 0x8a,
	0x81, 0x6b, 0xd7, 0x6a, 0x93, 0x3c, 0x72, 0x51, 0xfa, 0x7d, 0x6e, 0x0d, 0x71, 0x9e, 0x86, 0x7a,
	0xc5, 0x30, 0xac, 0x73, 0xf1, 0xd5, 0xa8, 0x88, 0xdd, 0x76, 0x3a, 0xe0, 0x26, 0x29, 0xe1, 0xa7,
	0x9e, 0x6e, 0x62, 0x75, 0xec, 0x01, 0x8d, 0x23, 0x0b, 0x36, 0x76, 0x57, 0xef, 0x93, 0x4a, 0xeb,
	0xcf, 0x39, 0x49, 0xdf, 0x5e, 0x8e, 0x5e, 0xad, 0x97, 0x7d, 0x6a, 0x89, 0x89, 0x25, 0xa5, 0x38,
	0x16, 0x5e, 0x23, 0xdc, 0xa9, 0x31, 0x84, 0x2b, 0x13, 0xe7, 0x31, 0xb3, 0xc3, 0x2b, 0xe1, 0x7c,
	0xe9, 0xc8, 0x65, 0x11, 0x6e, 0xd8, 0x10, 0xd1, 0x2d, 0xd3, 0x4e, 0x5b, 0xe7, 0xa2, 0xba, 0x1a,
	0xd8, 0x8c, 0xa7, 0x8c, 0xd0, 0x26, 0x39, 0x31, 0x4f, 0x37, 0x01, 0x06, 0x66, 0x1c, 0xb5, 0x80,
	0x93, 0x80, 0x33, 0x45, 0x73, 0x59, 0xdf, 0x52, 0xbb, 0x68, 0xac, 0x6b, 0xb2, 0x55, 0x04, 0x6a,
	0x28, 0x58, 0x28, 0x52, 0x29, 0x5b, 0xc5, 0x8e, 0xbe, 0xd5, 0xe8, 0x1a, 0x29, 0x47, 0xbd, 0x13,
	0x01, 0x15, 0x24, 0x19, 0xb6, 0x4b, 0x4f, 0x37, 0x5d, 0x9b, 0x19, 0xed, 0x14, 0x17, 0x02, 0x78,
	0x61, 0x11, 0xf8, 0x3e, 0x6d, 0x95, 0x7e, 0x06, 0x9f, 0x86, 0xde, 0x92, 0x4e, 0x92, 0x17, 0x73,
	0xd0, 0x3b, 0x65, 0x9c, 0xd4, 0xb0, 0xbd, 0x52, 0x7c, 0xd7, 0x0c, 0xea, 0xf8, 0x45, 0xe3, 0x4e,
	0x0c, 0xb9, 0x60, 0x43, 0xf5, 0x26, 0x76, 0x42, 0xfa, 0xbe, 0x69, 0xe5, 0x56, 0xeb, 0x27, 0x00,
	0xc9, 0xaf, 0x57, 0x2c, 0x4e, 0x94, 0xbc, 0x09, 0xd9, 0xc0, 0xf2, 0x8b, 0x7f, 0xa6, 0xc8, 0x97,
	0x91, 0xa2, 0x37, 0x21, 0xd9, 0xd3, 0xcb, 0xbf, 0xbe, 0x3d, 0xc8, 0x7c, 0xf7, 0xf6, 0x20, 0xf3,
	0xcf, 0xb7, 0x07, 0x99, 0xdf, 0xbf, 0x3b, 0xd8, 0xf8, 0xee, 0xdd, 0xc1, 0xc6, 0xdf, 0xdf, 0x1d,
	0x6c, 0x40, 0xc3, 0x0f, 0xae, 0x8e, 0xc7, 0x2f, 0x47, 0xd3, 0xf9, 0x6c, 0xf4, 0xca, 0x0b, 0x8e,
	0x6f, 0x2e, 0xc3, 0x9f, 0x05, 0xcf, 0xd3, 0xa8, 0x1f, 0x5c, 0x9d, 0x24, 0xe2, 0x0f, 0xae, 0xfc,
	0x93, 0x9b, 0xcb, 0x13, 0xf1, 0xef, 0xba, 0x2b, 0xff, 0x44, 0xda, 0x5f, 0x16, 0x85, 0xfc, 0xe5,
	0xbf, 0x03, 0x00, 0x00, 0xff, 0xff, 0x41, 0xeb, 0xf6, 0x7c, 0x17, 0x14, 0x00, 0x00,
}

func (m *ContractId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.RuntimeType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.RuntimeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ContractVersion) > 0 {
		i -= len(m.ContractVersion)
		copy(dAtA[i:], m.ContractVersion)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractVersion)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.ContractName) > 0 {
		i -= len(m.ContractName)
		copy(dAtA[i:], m.ContractName)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ContractName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for iNdEx := len(m.ContractTransaction) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ContractTransaction[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ContractTransaction) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractTransaction) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractTransaction) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.TxId) > 0 {
		i -= len(m.TxId)
		copy(dAtA[i:], m.TxId)
		i = encodeVarintContract(dAtA, i, uint64(len(m.TxId)))
		i--
		dAtA[i] = 0x12
	}
	if m.ContractId != nil {
		{
			size, err := m.ContractId.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Contract) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Contract) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Contract) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Address != nil {
		{
			size, err := m.Address.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x52
	}
	if m.Creator != nil {
		{
			size, err := m.Creator.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x4a
	}
	if m.CreateTime != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.CreateTime))
		i--
		dAtA[i] = 0x40
	}
	if m.UpdatePolicy != nil {
		{
			size, err := m.UpdatePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.EndorsePolicy != nil {
		{
			size, err := m.EndorsePolicy.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintContract(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x32
	}
	if m.Type != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x28
	}
	if m.Status != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.RuntimeType != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.RuntimeType))
		i--
		dAtA[i] = 0x18
	}
	if len(m.Version) > 0 {
		i -= len(m.Version)
		copy(dAtA[i:], m.Version)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Version)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ContractList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ContractList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ContractList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Contracts) > 0 {
		for iNdEx := len(m.Contracts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Contracts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *Epoch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Epoch) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Epoch) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NextEpochCreateHeight != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.NextEpochCreateHeight))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ProposerVector) > 0 {
		for iNdEx := len(m.ProposerVector) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ProposerVector[iNdEx])
			copy(dAtA[i:], m.ProposerVector[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.ProposerVector[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.EpochID != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.EpochID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Validator) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Validator) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Validator) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SelfDelegation) > 0 {
		i -= len(m.SelfDelegation)
		copy(dAtA[i:], m.SelfDelegation)
		i = encodeVarintContract(dAtA, i, uint64(len(m.SelfDelegation)))
		i--
		dAtA[i] = 0x42
	}
	if m.UnbondingCompletionEpochID != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.UnbondingCompletionEpochID))
		i--
		dAtA[i] = 0x38
	}
	if m.UnbondingEpochID != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.UnbondingEpochID))
		i--
		dAtA[i] = 0x30
	}
	if len(m.DelegatorShares) > 0 {
		i -= len(m.DelegatorShares)
		copy(dAtA[i:], m.DelegatorShares)
		i = encodeVarintContract(dAtA, i, uint64(len(m.DelegatorShares)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Tokens) > 0 {
		i -= len(m.Tokens)
		copy(dAtA[i:], m.Tokens)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Tokens)))
		i--
		dAtA[i] = 0x22
	}
	if m.Status != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x18
	}
	if m.Jailed {
		i--
		if m.Jailed {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x10
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Delegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Delegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Delegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Shares) > 0 {
		i -= len(m.Shares)
		copy(dAtA[i:], m.Shares)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Shares)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintContract(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegation) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegation) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegation) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if len(m.ValidatorAddress) > 0 {
		i -= len(m.ValidatorAddress)
		copy(dAtA[i:], m.ValidatorAddress)
		i = encodeVarintContract(dAtA, i, uint64(len(m.ValidatorAddress)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DelegatorAddress) > 0 {
		i -= len(m.DelegatorAddress)
		copy(dAtA[i:], m.DelegatorAddress)
		i = encodeVarintContract(dAtA, i, uint64(len(m.DelegatorAddress)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.EpochID) > 0 {
		i -= len(m.EpochID)
		copy(dAtA[i:], m.EpochID)
		i = encodeVarintContract(dAtA, i, uint64(len(m.EpochID)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *UnbondingDelegationEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UnbondingDelegationEntry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UnbondingDelegationEntry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Amount) > 0 {
		i -= len(m.Amount)
		copy(dAtA[i:], m.Amount)
		i = encodeVarintContract(dAtA, i, uint64(len(m.Amount)))
		i--
		dAtA[i] = 0x1a
	}
	if m.CompletionEpochID != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.CompletionEpochID))
		i--
		dAtA[i] = 0x10
	}
	if m.CreationEpochID != 0 {
		i = encodeVarintContract(dAtA, i, uint64(m.CreationEpochID))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ValidatorVector) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ValidatorVector) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ValidatorVector) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Vector) > 0 {
		for iNdEx := len(m.Vector) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Vector[iNdEx])
			copy(dAtA[i:], m.Vector[iNdEx])
			i = encodeVarintContract(dAtA, i, uint64(len(m.Vector[iNdEx])))
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DelegationInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DelegationInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DelegationInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for iNdEx := len(m.Infos) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Infos[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintContract(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintContract(dAtA []byte, offset int, v uint64) int {
	offset -= sovContract(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ContractId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ContractName)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ContractVersion)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RuntimeType != 0 {
		n += 1 + sovContract(uint64(m.RuntimeType))
	}
	return n
}

func (m *ContractInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.ContractTransaction) > 0 {
		for _, e := range m.ContractTransaction {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *ContractTransaction) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ContractId != nil {
		l = m.ContractId.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.TxId)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *Contract) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Version)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.RuntimeType != 0 {
		n += 1 + sovContract(uint64(m.RuntimeType))
	}
	if m.Status != 0 {
		n += 1 + sovContract(uint64(m.Status))
	}
	if m.Type != 0 {
		n += 1 + sovContract(uint64(m.Type))
	}
	if m.EndorsePolicy != nil {
		l = m.EndorsePolicy.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.UpdatePolicy != nil {
		l = m.UpdatePolicy.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.CreateTime != 0 {
		n += 1 + sovContract(uint64(m.CreateTime))
	}
	if m.Creator != nil {
		l = m.Creator.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Address != nil {
		l = m.Address.Size()
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ContractList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Contracts) > 0 {
		for _, e := range m.Contracts {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *Epoch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.EpochID != 0 {
		n += 1 + sovContract(uint64(m.EpochID))
	}
	if len(m.ProposerVector) > 0 {
		for _, s := range m.ProposerVector {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	if m.NextEpochCreateHeight != 0 {
		n += 1 + sovContract(uint64(m.NextEpochCreateHeight))
	}
	return n
}

func (m *Validator) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.Jailed {
		n += 2
	}
	if m.Status != 0 {
		n += 1 + sovContract(uint64(m.Status))
	}
	l = len(m.Tokens)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.DelegatorShares)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if m.UnbondingEpochID != 0 {
		n += 1 + sovContract(uint64(m.UnbondingEpochID))
	}
	if m.UnbondingCompletionEpochID != 0 {
		n += 1 + sovContract(uint64(m.UnbondingCompletionEpochID))
	}
	l = len(m.SelfDelegation)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *Delegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.Shares)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *UnbondingDelegation) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.EpochID)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.DelegatorAddress)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	l = len(m.ValidatorAddress)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *UnbondingDelegationEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.CreationEpochID != 0 {
		n += 1 + sovContract(uint64(m.CreationEpochID))
	}
	if m.CompletionEpochID != 0 {
		n += 1 + sovContract(uint64(m.CompletionEpochID))
	}
	l = len(m.Amount)
	if l > 0 {
		n += 1 + l + sovContract(uint64(l))
	}
	return n
}

func (m *ValidatorVector) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Vector) > 0 {
		for _, s := range m.Vector {
			l = len(s)
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func (m *DelegationInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Infos) > 0 {
		for _, e := range m.Infos {
			l = e.Size()
			n += 1 + l + sovContract(uint64(l))
		}
	}
	return n
}

func sovContract(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozContract(x uint64) (n int) {
	return sovContract(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ContractId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeType", wireType)
			}
			m.RuntimeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeType |= RuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractTransaction", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractTransaction = append(m.ContractTransaction, &ContractTransaction{})
			if err := m.ContractTransaction[len(m.ContractTransaction)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractTransaction) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractTransaction: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractTransaction: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractId", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ContractId == nil {
				m.ContractId = &ContractId{}
			}
			if err := m.ContractId.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TxId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TxId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Contract) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Contract: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Contract: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Version = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RuntimeType", wireType)
			}
			m.RuntimeType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RuntimeType |= RuntimeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= ContractStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ContractType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndorsePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EndorsePolicy == nil {
				m.EndorsePolicy = &accesscontrol.Policy{}
			}
			if err := m.EndorsePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdatePolicy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UpdatePolicy == nil {
				m.UpdatePolicy = &accesscontrol.Policy{}
			}
			if err := m.UpdatePolicy.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateTime", wireType)
			}
			m.CreateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreateTime |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Creator", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Creator == nil {
				m.Creator = &accesscontrol.SerializedMember{}
			}
			if err := m.Creator.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Address == nil {
				m.Address = &accesscontrol.SerializedMember{}
			}
			if err := m.Address.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ContractList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContractList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContractList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Contracts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Contracts = append(m.Contracts, &Contract{})
			if err := m.Contracts[len(m.Contracts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Epoch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Epoch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Epoch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochID", wireType)
			}
			m.EpochID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EpochID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ProposerVector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ProposerVector = append(m.ProposerVector, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextEpochCreateHeight", wireType)
			}
			m.NextEpochCreateHeight = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NextEpochCreateHeight |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Validator) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Validator: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Validator: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jailed", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Jailed = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= BondStatus(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Tokens", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Tokens = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorShares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorShares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingEpochID", wireType)
			}
			m.UnbondingEpochID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingEpochID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnbondingCompletionEpochID", wireType)
			}
			m.UnbondingCompletionEpochID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnbondingCompletionEpochID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfDelegation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfDelegation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Delegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Delegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Delegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shares", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Shares = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegation) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegation: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegation: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EpochID", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EpochID = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DelegatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DelegatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidatorAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ValidatorAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &UnbondingDelegationEntry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UnbondingDelegationEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UnbondingDelegationEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UnbondingDelegationEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationEpochID", wireType)
			}
			m.CreationEpochID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreationEpochID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompletionEpochID", wireType)
			}
			m.CompletionEpochID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompletionEpochID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Amount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Amount = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ValidatorVector) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ValidatorVector: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ValidatorVector: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Vector = append(m.Vector, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DelegationInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowContract
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DelegationInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DelegationInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Infos", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowContract
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthContract
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthContract
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Infos = append(m.Infos, &Delegation{})
			if err := m.Infos[len(m.Infos)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipContract(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthContract
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipContract(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowContract
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowContract
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthContract
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupContract
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthContract
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthContract        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowContract          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupContract = fmt.Errorf("proto: unexpected end of group")
)
